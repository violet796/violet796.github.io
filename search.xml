<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据分析库:Numpy的使用</title>
      <link href="/2025/09/21/shu-ju-fen-xi-ku-numpy-de-shi-yong/"/>
      <url>/2025/09/21/shu-ju-fen-xi-ku-numpy-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><strong>Numpy</strong>和<strong>Pandas，Matplotlib</strong>（或 <strong>Scikit-learn</strong>）并称为数据分析中主要的三个核心库。它提供了大量方法，能够快速地求得某些统计值，以及实现对不同向量、矩阵的计算。</p><h2 id="Numpy的安装"><a href="#Numpy的安装" class="headerlink" title="Numpy的安装"></a>Numpy的安装</h2><ul><li>通过<strong>Python</strong>的<strong>pip</strong>命令安装</li></ul><pre class="language-powershell" data-language="powershell"><code class="language-powershell">pip install <span class="token operator">--</span>upgrade pip <span class="token comment">#先升级pip</span>pip install numpy <span class="token comment">#安装最新版本的numpy</span>或pip install numpy==version <span class="token comment">#指定版本号，version为要安装的版本号</span></code></pre><ul><li>安装<strong>Anaconda</strong></li></ul><p><strong>Anaconda</strong>集成了大量<strong>Python</strong>常用库，如Numpy，Pandas等。如果要安装特定版本的库，只需要在<strong>Anaconda Navigator</strong>中搜索即可，如图所示。</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921153004937.png" alt="在Anaconda搜索需要的库"></p><p>方法一可以只安装需要的<strong>Numpy</strong>库，对电脑的存储空间要求较小，但是操作相对来说更繁琐一些。方法二安装<strong>Anaconda</strong>，由于集成了大量库，故对存储空间的要求相对高得多，但是操作较为便捷。使用者可以根据自己的实际情况选择安装方法。</p><p>安装后，可通过下列命令判断是否安装成功:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>__version__<span class="token punctuation">)</span></code></pre><p>若安装成功，将会输出所安装的版本号，如图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921154116473.png" alt="安装成功输出图"></p><h2 id="Numpy的使用"><a href="#Numpy的使用" class="headerlink" title="Numpy的使用"></a>Numpy的使用</h2><p>下文大部分代码均是在导入了numpy库的前提下才能使用的，在成功安装numpy后，导入代码如下:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np</code></pre><h3 id="1-ndarray"><a href="#1-ndarray" class="headerlink" title="1.ndarray"></a>1.ndarray</h3><p><strong>ndarray</strong>是通过<strong>Numpy</strong>创造出来的数组，它具有<em>多维性</em>、<em>同质性</em>、<em>高效性</em>的特点。<strong>ndarray</strong>最基本的生成命令为:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#零维(标量)</span>arr0 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token comment">#一维(向量)</span>arr1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>nums3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#二维(矩阵)</span>arr2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>nums1<span class="token punctuation">,</span>nums2<span class="token punctuation">,</span>nums3<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>nums4<span class="token punctuation">,</span>nums5<span class="token punctuation">,</span>nums6<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>下文将介绍更多种类型的命令。</p><p><strong>ndarray</strong>三个特性的具体含义如下。</p><p><strong>① 多维性</strong></p><p>指的是<strong>ndarray</strong>支持多种维度，如0维(一个数)、1维(一个向量)、2维(矩阵)或更高维。</p><p>对于上文生成的三个数组，获取其维度，结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921160040501.png" alt="ndarray的多维性"></p><p><strong>② 同质性</strong></p><p>指的是<strong>ndarray</strong>当中所有元素的类型都是一样的，不像Python的原生列表，列表中的元素可以涵盖从整型到字符串的多种元素。</p><p>将元素<em>1</em>，和其它不同类型的元素组成列表，并生成一个<strong>ndarray</strong>，可以看到三个均包含元素<em>1</em>的<strong>ndarray</strong>的类型如图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921163641364.png" alt="ndarray的同质性"></p><p><strong>ndarray</strong>自动将元素的类型进行了转换。</p><p><strong>③ 高效性</strong> </p><p><strong>ndarray</strong>基于连续的内存块存储，支持矩阵的乘法，矩阵的快速切片等。</p><h3 id="2-ndarray的创建"><a href="#2-ndarray的创建" class="headerlink" title="2.ndarray的创建"></a>2.ndarray的创建</h3><p>通过<strong>Numpy</strong>的不同方法可以创建各种各样的<strong>ndarray</strong>，具体如下所示:</p><p><code>① 最基本的创建方法</code></p><p>如第一部分<strong>ndarray</strong>所示，通过<strong>array</strong>方法可以自定义创建不同维度的<strong>ndarray</strong>。</p><pre class="language-python" data-language="python"><code class="language-python">arr0 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#0维标量</span>arr1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#1维向量</span>arr2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#2维矩阵</span></code></pre><p>在有了一个<strong>ndarray</strong>后，若想复制这个<strong>ndarray</strong>的值，可以使用**copy( )**方法，如下所示:</p><pre class="language-python" data-language="python"><code class="language-python">arr3 <span class="token operator">=</span> np<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>arr2<span class="token punctuation">)</span></code></pre><p><strong>copy</strong>方法只复制<strong>ndarray</strong>的值，不复制地址。也就是说两者之间自身的改动并不影响对方的值。</p><p><code>② 预定义数组的形状</code></p><p><strong>a) 创建一个全0，全1的数组</strong></p><pre class="language-none"><code class="language-none">arr_0 = np.zeros(shape=(3,4),dtype=int) #shape可省略arr_1 = np.ones(shape=(3,),dtype=int) #shape可省略</code></pre><p>通过<strong>zeros( )<strong>和</strong>ones( )<strong>方法创建全 0 和全 1 的数组。方法的 <strong>shape</strong> 参数决定了数组的形状，<strong>dtype</strong>参数决定了数组的元素类型，默认为浮点型。对于参数</strong>shape</strong>，<strong>shape=3</strong>和**shape=(3 , )*<em>的写法在实现效果上完全一样，均代表创建一个一维行向量，且这个行向量的长度为</em>3*，但是带括号能使得写法更为统一。</p><p>输出<strong>arr_0</strong>和<strong>arr_1</strong>的结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921170038871.png" alt="创建全0和全1的数组"></p><p><strong>b) 创建一个未初始的数组</strong></p><p>有时候只需要创建一个未初始化的数组，而无需定义具体的值，可以使用**empty( )**方法。</p><pre class="language-python" data-language="python"><code class="language-python">arr_e <span class="token operator">=</span> np<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#shape可省略</span></code></pre><p>同样通过<strong>shape</strong>参数决定数组的形状，但由于元素未初始化，所以每次运行时，数组内元素的结果将是随机的，如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921170606194.png" alt="未初始化的数组"></p><p><strong>c) 创建一个全为固定值的数组</strong></p><p>如果希望数组内的填充元素既非0又非1，可以通过**full( )**方法来指定需要创建的数组规模以及填充的元素。</p><pre class="language-python" data-language="python"><code class="language-python">arr_f <span class="token operator">=</span> np<span class="token punctuation">.</span>full<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fill_value<span class="token operator">=</span><span class="token number">2025</span><span class="token punctuation">)</span> <span class="token comment">#shape和fill_value可省略</span></code></pre><p><strong>shape</strong>参数指定数组形状，<strong>fill_value</strong>指定需要填充的值。运行结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921171319782.png" alt="指定填充元素的数组"></p><p><strong>d) 根据已知数组创造同型全0数组</strong></p><p>如果想要创造一个全零数组，且该全零数组的形状和某个已有数组的形状一样，可以使用<strong>zeros_like( )<strong>方法。如创造一个如</strong>arr_f</strong>一样的3*3全零数组：</p><pre class="language-python" data-language="python"><code class="language-python">arr_0l <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>arr_f<span class="token punctuation">)</span></code></pre><p>输出<strong>arr_0l</strong>结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921201833505.png" alt="创建同型全零数组"></p><p><code>③ 创建特殊的等间距数组</code></p><p><strong>a) 已知步长，创建元素为等差数列的数组</strong></p><p>使用**arange(start,end,step)**方法，创建出来的数组元素的范围为[start,end)，左闭右开。<strong>start</strong>为数组的开始元素，<strong>end - 1</strong>为数组的结尾元素，<strong>step</strong>为该等差数列的步长。</p><pre class="language-python" data-language="python"><code class="language-python">arr_aran <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><p>上述代码创建了一个元素为等差数列的数组。数组元素从1开始，到9结束，公差为2。打印数组结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921202600765.png" alt="arange()方法创建的数组"></p><p> <strong>b) 知道所需元素的首尾和个数，创建元素间隔相同的数组</strong></p><p>使用**linspace(start,end,num)**方法，创建出来的数组元素范围为[start,end]，左闭右闭。<strong>start</strong>为数组的开始元素，<strong>end</strong>为数组的结尾元素，<strong>num</strong>为数组的元素个数。</p><pre class="language-python" data-language="python"><code class="language-python">arr_lins <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span></code></pre><p> 上述代码创建了一个长度为5，以1开头，以10结尾的等间隔数组。打印数组结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921203911978.png" alt="linspace()方法创建的数组"></p><p>如果在此基础上，需要继续求底数<strong>base</strong>的各个元素次方，可以使用<strong>logspace(start,end,num,base)<strong>方法，该方法先和</strong>linspace( )<strong>方法一样，创建出等间隔数组，再将</strong>base</strong>的每个数组元素次方作为结果存入数组中。打印数组结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921204828951.png" alt="logspace()方法创建的数组"></p><p><code>④ 创建特殊矩阵</code></p><p><strong>a) 创建n维单位矩阵</strong></p><pre class="language-python" data-language="python"><code class="language-python">arr_e <span class="token operator">=</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>**eye( )**方法创建了一个3维的单位矩阵，打印矩阵结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921205138720.png" alt="eye()方法创建的单位矩阵"></p><p><strong>b) 自定义创建对角矩阵</strong></p><pre class="language-python" data-language="python"><code class="language-python">arr_d <span class="token operator">=</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>对角矩阵为除了主对角线以外，其余元素均为0的矩阵。**diag( )**方法通过接收对角线元素列表，创建一个维数等于对角线元素列表长度的对角矩阵。打印矩阵结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921210127681.png" alt="diag()方法创建的矩阵"></p><p><code>⑤ 创建随机数组</code></p><p><strong>a) 生成[0,1)之间的指定形状的浮点型数组</strong></p><pre class="language-python" data-language="python"><code class="language-python">arr_01f <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>使用<strong>random.rand( row,column)<strong>方法，参数</strong>row</strong>代表要生成的行数，参数<strong>column</strong>代表要生成的列数。打印数组结果如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921210904342.png" alt="random.rand()方法创建的数组"></p><p>数组中的元素符合[0,1)之间的均匀分布。</p><p><strong>b) 生成指定区间的指定形状的浮点型数组</strong></p><pre class="language-python" data-language="python"><code class="language-python">arr_u <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>使用**random.uniform(start,end,shape)*<em>方法。上面这行代码将生成大小为2</em>3，元素为[3,4)之间的浮点数的数组。打印数组结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921211354510.png" alt="random.uniform()方法创建的数组"></p><p>数组中的元素符合[3,4)之间的均匀分布。</p><p><strong>c) 生成指定区间的指定形状的整型数组</strong></p><pre class="language-python" data-language="python"><code class="language-python">arr_i <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>使用**random.randint(start,end,shape)*<em>方法。上面这行代码将生成大小3</em>3，元素为[1,10)之间的整型的数组。打印数组结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921213102395.png" alt="random.randint()方法创建的数组"></p><p>数组中的元素符合[1,10)之间的均匀分布。</p><p><strong>d) 生成服从正态分布的数组</strong></p><pre class="language-python" data-language="python"><code class="language-python">arr_nd <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>使用<strong>random.randn(shape)<strong>方法。上面这行代码将生成大小3*3，元素服从</strong>均值为0，标准差为1</strong>的标准正态分布的数组。打印数组结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921213550544.png" alt="random.randn()方法创建的数组"></p><p><strong>e) 固定随机生成的数组</strong></p><p>有时候若想一直使用某个随机生成的数组，那么可以在使用上述<strong>random.<strong>方法之前，给</strong>numpy</strong>设置一个种子。</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>设置了种子之后，无论执行多少次**random.**方法，最后生成的数组结果都是一样的。</p><h3 id="3-ndarray的属性"><a href="#3-ndarray的属性" class="headerlink" title="3.ndarray的属性"></a>3.ndarray的属性</h3><p>在使用<strong>Numpy</strong>创建了<strong>ndarray</strong>后，可以通过<strong>数组名.属性</strong>的方法获取对应的属性。</p><p>假设有一个<strong>ndarray</strong>，数组名为<strong>arr</strong>，则它具有下列几个主要的属性：</p><table><thead><tr><th align="center">属性名</th><th align="center">调用方式</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">维度</td><td align="center">arr.ndim</td><td align="center">获得当前数组的维度</td></tr><tr><td align="center">类型</td><td align="center">arr.dtype</td><td align="center">获得当前数组的元素类型</td></tr><tr><td align="center">形状</td><td align="center">arr.shape</td><td align="center">获得当前数组的形状<br>如(3,4)代表三行四列</td></tr><tr><td align="center">大小</td><td align="center">arr.size</td><td align="center">获得当前数组中的元素个数</td></tr><tr><td align="center">转置</td><td align="center">arr.T</td><td align="center">将当前数组转置（需要数组为矩阵）</td></tr><tr><td align="center">元素字节大小</td><td align="center">arr.itemsize</td><td align="center">获得当前数组的元素字节大小</td></tr></tbody></table><h3 id="4-ndarray的数据类型"><a href="#4-ndarray的数据类型" class="headerlink" title="4.ndarray的数据类型"></a>4.ndarray的数据类型</h3><table><thead><tr><th align="center">类型</th><th align="center">表达式</th></tr></thead><tbody><tr><td align="center">布尔</td><td align="center">bool</td></tr><tr><td align="center">整型</td><td align="center">int(有符号整型)<br>unit(无符号整型)</td></tr><tr><td align="center">浮点</td><td align="center">float</td></tr><tr><td align="center">复数</td><td align="center">complex</td></tr></tbody></table><p>每种数据类型根据定义的位数不同，所能表示的范围也有所不同。</p><h3 id="5-ndarray的索引和切片"><a href="#5-ndarray的索引和切片" class="headerlink" title="5.ndarray的索引和切片"></a>5.ndarray的索引和切片</h3><p><strong>ndarray</strong>可以同时对行，列向量进行切片，同<strong>python</strong>的原生列表一样，使用**[:]**对数组进行切片。</p><p>一维<strong>ndarray</strong>的索引和普通数组并无区别，下标从<strong>0</strong>开始，到**len(ndarray)**结束。</p><p>对于一个一维的<strong>ndarray</strong>，数组名为<strong>arr1</strong>，长度大于8。假设要获得其第5到第8个元素，使用下列方式进行切片:</p><pre class="language-python" data-language="python"><code class="language-python">arr_c <span class="token operator">=</span> arr1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span></code></pre><p>切片arr1[start:end]，取到的是下标为[start,end - 1]的子数组。故该代码可取到下标为[4:7]的子数组，正好对应第5到第8个元素。将<strong>arr_c</strong>打印，结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921224241676.png" alt="一维数组的切片"></p><p><strong>ndarray</strong>切片返回的值为其<strong>视图</strong>，也就是修改切片，<strong>ndarray</strong>也会一起被修改。</p><p>对于<strong>ndarray</strong>来说，切片的内容可以通过布尔索引进行自定义。</p><p>假设我需要找出一个名称为<strong>arr1</strong>的<strong>ndarray</strong>中的所有值大于5的元素，则可以通过:</p><pre class="language-python" data-language="python"><code class="language-python">arr_b <span class="token operator">=</span> arr1<span class="token punctuation">[</span>arr1<span class="token operator">&gt;</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre><p>这种方式叫做<strong>布尔索引</strong>。形式如arr[<strong>一个和arr规模一样的Bool类型数组</strong>]。在使用<strong>布尔索引</strong>的过程中，数组的每一个元素都对应一个<strong>布尔值</strong>，只有该值为<strong>True</strong>，对应的元素才会被保留。</p><p>对于该代码，<strong>arr1&gt;5</strong>首先生成了一个和arr1规模一样的<strong>bool</strong>类型数组，只有元素的值大于5，对应位置的bool值才为<strong>Ture</strong>。这个数组作为<strong>布尔索引</strong>的布尔矩阵，并保留符合条件的值并赋给<strong>arr_b</strong>。输出结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921225317852.png" alt="布尔索引"></p><p><strong>布尔索引</strong>返回的值为其<strong>副本</strong>，也就是修改得到的数组，<strong>ndarray</strong>不会一起被修改。</p><p>如果切片的对象不是连续值，而是某一个区间内索引长度固定的离散值，可以使用**arr[slice(start,end,step)]**方法:</p><pre class="language-python" data-language="python"><code class="language-python">arr_s <span class="token operator">=</span> arr1<span class="token punctuation">[</span><span class="token builtin">slice</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  </code></pre><p>该方法将相隔两个元素输出arr1下标为[4:7]的元素，输出结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921231341998.png" alt="按照步长切片"></p><p>二维<strong>ndarray</strong>的索引方式为<strong>ndarray[1,3]</strong>。这表示直接获得该数组的第二行第四个元素。使用<code>ndarray[1][3]</code>虽然也可以获得相应的元素，但这种方法的实现逻辑是先生成<code>ndarrat[1]</code>这个中间数组，再从这个中间数组中找到第4个元素，效率较低。</p><p><strong>ndarray</strong>也支持对二维数组的快速切片，假设有一个规模为3<em>4的二维数组*<em>arr2</em></em>。要对其第一行到第二行、第二列到第四列切片。具体的方法如下:</p><pre class="language-python" data-language="python"><code class="language-python">arr_a <span class="token operator">=</span> arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span></code></pre><p>行列的下标输入方法和一维切片完全一致，通过形如**arr2[起始行下标:结尾行下标 + 1,起始列下标:起始列下标 + 1]**的方式，实现对二维数组的行列同时切片。二维数组切片结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921230557801.png" alt="二维数组的切片"></p><p>二维<strong>ndarray</strong>也可以只对行或者列切片,具体的方法如下:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#对某一行的特定列切片</span>arr2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token comment">#对某一列切片</span>arr2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre><p>对行或列切片结果如图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250921232734958.png" alt="二维ndarray对特定行列切片"></p><h3 id="6-ndarray的计算"><a href="#6-ndarray的计算" class="headerlink" title="6.ndarray的计算"></a>6.ndarray的计算</h3><p>假设有两个同型二维数组<strong>arr1</strong>和<strong>arr2</strong>，以这两个数组为例说明<strong>ndarray</strong>的计算。</p><table><thead><tr><th align="center">计算方式</th><th align="center">表达式</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">求和</td><td align="center">arr1 + arr2</td><td align="center">两矩阵对应元素相加</td></tr><tr><td align="center">做差</td><td align="center">arr1 - arr2</td><td align="center">两矩阵对应元素相减</td></tr><tr><td align="center">乘法</td><td align="center">arr1 * arr2</td><td align="center">两矩阵对应元素相乘</td></tr><tr><td align="center">除法</td><td align="center">arr1 / arr2</td><td align="center">两矩阵对应元素相除</td></tr><tr><td align="center">矩阵乘法</td><td align="center">arr1 @ arr2</td><td align="center">两矩阵做矩阵乘法</td></tr></tbody></table><blockquote><p>对矩阵乘法的补充：对于规模为a * b的矩阵A和规模为c * d的矩阵B，只有当b = c时，才能有A * B = C，且C的规模为a * d。</p><p>C矩阵的第(i,j)项由，A矩阵的第i行(i &lt;= a)和B矩阵的第j列(j &lt;= d)逐项相乘再相加得到。</p></blockquote><p>对于不同型的二维数组<strong>arr3</strong>和<strong>arr4</strong>，假设<strong>arr3</strong>的规模为<code>m*n</code>，<strong>arr4</strong>的规模为<code>a*b</code>。两个二维数组要想做对应运算需要满足下列条件之一：</p><ul><li><p>m = a 且 n = b</p></li><li><p>m != a 但 m 和 a 当中有一个为1，n = b</p></li><li><p>m = a，n != b 但 n 和 b 当中有一个为1</p></li><li><p>m != a 但 m 和 a 当中有一个为1，n != b 但 n 和 b 当中有一个为1</p></li></ul><p>这种机制叫做广播。当判断两个二维数组不同型，但是又满足上述条件之一，<strong>ndarray</strong>会自动将其扩充成同型数组。</p><p>假设<strong>arr3</strong>的规模是3 * 4，<strong>arr4</strong>的规模是1 * 4。这符合上述第二种情况，<strong>arr4</strong>会被扩充为规模为3 * 4的数组，并做对应运算，以加法为例，运算结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922151535849.png" alt="广播机制示例一"></p><p>可以看到运算结果是<strong>arr3</strong>和<strong>arr4</strong>经过广播后得到的一个规模为3 * 4，且每一行均为[5,3,5,8]的矩阵相加得来的。</p><p>再假设<strong>arr3</strong>的规模是1* 4，<strong>arr4</strong>的规模是4 * 1。这符合上述第四种情况，<strong>arr3</strong>和<strong>arr4</strong>均会被扩充为规模为4 * 4的数组，并做对应运算，以加法为例，运算结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922152032871.png" alt="广播机制示例二"></p><p>可以看到运算结果是由一个每一行均为[6,9,6,1]的4 * 4矩阵和一个每一列均为[1,2,8,7]的4 * 4矩阵相加得来的。这两个矩阵分别由<strong>arr3</strong>和<strong>arr4</strong>广播得到。</p><h3 id="7-Numpy常用的数学方法"><a href="#7-Numpy常用的数学方法" class="headerlink" title="7.Numpy常用的数学方法"></a>7.Numpy常用的数学方法</h3><p><strong>Numpy</strong>常用的数学方法如下表所示:</p><table><thead><tr><th align="center">方法名</th><th align="center">方法效果</th><th align="center">使用方式</th><th align="center">输出结果</th></tr></thead><tbody><tr><td align="center">sqrt(x)</td><td align="center">对一个数或数组开方</td><td align="center">np.sqrt(9)<br>np.sqrt([1,4,9,16])</td><td align="center">3<br>[1,2,3,4]</td></tr><tr><td align="center">exp(x)</td><td align="center">计算e的x次方</td><td align="center">np.exp(2)</td><td align="center">e²</td></tr><tr><td align="center">log(x)</td><td align="center">计算lnx</td><td align="center">np.log(2)</td><td align="center">ln2</td></tr><tr><td align="center">sin(x)/cos(x)</td><td align="center">计算正弦值/余弦值</td><td align="center">np.sin(1)/np.cos(1)</td><td align="center">sin1/cos1</td></tr><tr><td align="center">abs(x)</td><td align="center">计算一个数或数组的绝对值</td><td align="center">np.abs(-1)<br>np.abs([-2,-3,-4,-5])</td><td align="center">1<br>[2,3,4,5]</td></tr><tr><td align="center">power(a,b)</td><td align="center">计算a的b次方</td><td align="center">np.power(2,3)</td><td align="center">8</td></tr><tr><td align="center">round(x)</td><td align="center">四舍五入(采用银行家四舍五入法)</td><td align="center">np.round([3.2,4.5,8.1,9.6])</td><td align="center">[3,4,8,10]</td></tr><tr><td align="center">ceil(x)</td><td align="center">对x向上取整</td><td align="center">np.ceil(9.1)<br>np.ceil([1.2,4.1,7.2])</td><td align="center">10<br>[2,5,7]</td></tr><tr><td align="center">floor(x)</td><td align="center">对向下取整</td><td align="center">np.floor(9.1)<br>np.floor([1.2,4.1,7.2]</td><td align="center">9<br>[1,4,7]</td></tr><tr><td align="center">isnan(array)</td><td align="center">判断一个数是否缺失值，返回一个bool值<br>检测数组中是否有缺失值，输出一个bool数组</td><td align="center">np.isnan([1,2,np.nan,3])</td><td align="center">[False,False,TRUE,False]</td></tr></tbody></table><p><strong>isnan(array)<strong>方法的使用场景:在读取大量数据元素时，数据难免会有缺失值，Numpy会用</strong>np.nan</strong>填充这些缺失值，此时可以使用<strong>isnan(array)<strong>方法加</strong>布尔索引</strong>的方式快速找出非空元素。</p><h3 id="8-Numpy常用的统计方法"><a href="#8-Numpy常用的统计方法" class="headerlink" title="8.Numpy常用的统计方法"></a>8.Numpy常用的统计方法</h3><p><strong>Numpy</strong>常用的统计方法如下表所示:</p><table><thead><tr><th align="center">方法名</th><th align="center">方法效果</th><th align="center">使用方式</th><th align="center">输出结果</th></tr></thead><tbody><tr><td align="center">sum(array)</td><td align="center">求和</td><td align="center">np.sum([1,4,9,16])</td><td align="center">30</td></tr><tr><td align="center">mean(array)</td><td align="center">计算平均值</td><td align="center">np.mean([1,4,16])</td><td align="center">7</td></tr><tr><td align="center">median(array)</td><td align="center">计算中位数</td><td align="center">np.mean([1,4,5,6])</td><td align="center">4.5</td></tr><tr><td align="center">var(array)</td><td align="center">计算方差</td><td align="center">np.var([1,2,3,4])</td><td align="center">1.25</td></tr><tr><td align="center">std(array)</td><td align="center">计算标准差</td><td align="center">np.std([1,2,3,4])</td><td align="center">1.11</td></tr><tr><td align="center">max(array)</td><td align="center">计算最大值</td><td align="center">np.max([1,3,4,1])</td><td align="center">4</td></tr><tr><td align="center">argmax(array)</td><td align="center">计算第一个最大值的索引</td><td align="center">np.argmax([1,3,4,1])</td><td align="center">2</td></tr><tr><td align="center">min(array)</td><td align="center">计算最小值</td><td align="center">np.min[1,3,4,1])</td><td align="center">1</td></tr><tr><td align="center">argmin(array)</td><td align="center">计算第一个最小值的索引</td><td align="center">np.argmin([1,3,4,1])</td><td align="center">0</td></tr><tr><td align="center">percentile(array,n)</td><td align="center">计算arr的分位数</td><td align="center">np.percentile([1,2,3,4],25)</td><td align="center">1.75</td></tr><tr><td align="center">cumsum(array)</td><td align="center">计算数组的累积和</td><td align="center">np.cumsum([1,2,3,4])</td><td align="center">[1,3,6,10]</td></tr><tr><td align="center">cumprod(array)</td><td align="center">计算数组的累积积</td><td align="center">np.cumprod([1,2,3,4])</td><td align="center">[1,2,6,24]</td></tr></tbody></table><p>上述统计方法大部分都带有一个<strong>axis</strong>参数，通过指定<strong>axis = 0</strong>，可以只统计每一列的数学值、通过指定<strong>axis = 1</strong>，可以只统计每一行的数学值。如要求一个2  * 3的二维数组的每一行的<strong>最大值</strong>：</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>arr_m <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>arr_mr <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>arr_m<span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>打印数组结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922170626987.png" alt="对每一行进行统计"></p><blockquote><p>这种方式依然适用于其它统计方法。</p></blockquote><p><strong>分位数</strong>指的是对于给定数组，找到一个数，使得至少有**n%<strong>的数小于它,至少有</strong>(100- n)%<strong>的数大于它。<strong>Numpy</strong>的</strong>percentile(array,n)**方法分为两个步骤:</p><ul><li><p>将数组排序</p></li><li><p>计算**(len(array) - 1）* (n / 100)**，<strong>n</strong>为输入的数。</p></li></ul><p>​若结果恰为整数<strong>a</strong>，返回<strong>array[a]</strong> </p><p>​若结果不为整数，为一个浮点数<strong>b</strong>，且<code>i &lt; b &lt; j</code>，设<strong>b = i  + f</strong>，<strong>i</strong>为b的整数部分,<strong>f</strong>为b的小数部分。则返回<strong>array[i] + (arr[j] - arr[i]) * f</strong></p><h3 id="9-Numpy的比较方法"><a href="#9-Numpy的比较方法" class="headerlink" title="9.Numpy的比较方法"></a>9.Numpy的比较方法</h3><p><strong>Numpy</strong>的比较方法通常返回一个<strong>bool数组</strong>，常用的比较方法如下表所示:</p><table><thead><tr><th align="center">方法名</th><th align="center">方法效果</th><th align="center">使用方式</th><th align="center">输出结果</th></tr></thead><tbody><tr><td align="center">great(array,num)</td><td align="center">判断array中的每个元素是否大于num</td><td align="center">np.greater([3,4,5],4)</td><td align="center">[False False  True]</td></tr><tr><td align="center">less(array,num)</td><td align="center">判断array中的每个元素是否小于num</td><td align="center">np.less([3,3,5],4)</td><td align="center">[ True  True False]</td></tr><tr><td align="center">equal(array,num)</td><td align="center">判断array中的每个元素是否等于num</td><td align="center">np.equal([3,4,5],4)</td><td align="center">[False False  True]</td></tr><tr><td align="center">logical_and(arr1,arr2)</td><td align="center">arr1和arr2中的对应元素进行逻辑与</td><td align="center">np.logical_and([1,0],[1,1])</td><td align="center">[True,False]</td></tr><tr><td align="center">logical_or(arr1,arr2)</td><td align="center">arr1和arr2中的对应元素进行逻辑或</td><td align="center">np.logical_or([1,0],[1,1])</td><td align="center">[True,True]</td></tr><tr><td align="center">logical_not(array)</td><td align="center">对array中的每个元素真值取反</td><td align="center">np.logical_not([1,0])</td><td align="center">[False,True]</td></tr><tr><td align="center">any(array)</td><td align="center">判断array中有没有一个元素为真</td><td align="center">np.any([0,0,0,1])</td><td align="center">True</td></tr><tr><td align="center">all(array)</td><td align="center">判断array中是否所有元素为真</td><td align="center">np.all([1,1,1,0]</td><td align="center">False</td></tr></tbody></table><p>对于每一个比较方法，作为参数的两个数组依然具有<strong>广播机制</strong>。即，哪怕两数组不同型，但只要符合上文四点之一，就可以进行比较。</p><h3 id="10-Numpy的其它方法"><a href="#10-Numpy的其它方法" class="headerlink" title="10.Numpy的其它方法"></a>10.Numpy的其它方法</h3><p><strong>Numpy</strong>的一些其它常用方法如下表所示:</p><table><thead><tr><th align="center">方法名</th><th align="center">方法效果</th><th align="center">使用方式</th><th align="center">输出结果</th></tr></thead><tbody><tr><td align="center">where(condition, x, y)</td><td align="center">见下文</td><td align="center">见下文</td><td align="center">见下文</td></tr><tr><td align="center">select(condlist, choicelist, default=0)</td><td align="center">见下文</td><td align="center">见下文</td><td align="center">见下文</td></tr><tr><td align="center">sort(arr)</td><td align="center">排序(不改变数组本身，只是返回副本)</td><td align="center">np.sort([3,5,1,6])</td><td align="center">[1,3,5,6]</td></tr><tr><td align="center">argsort(arr)</td><td align="center">返回有序数组对应的原数组元素索引</td><td align="center">np.argsort([3,5,1,6])</td><td align="center">[2,0,1,3]</td></tr><tr><td align="center">unique(arr)</td><td align="center">排序并去重</td><td align="center">np.unique([1,2,1,3,2])</td><td align="center">[1,2,3]</td></tr><tr><td align="center">concatenate((arr,arr1))</td><td align="center">将arr和arr1拼接</td><td align="center">np.concatenate((arr,arr1))</td><td align="center">[arr,arr1]</td></tr><tr><td align="center">reshape(arr,(n,m))</td><td align="center">将arr重塑成n * m的形状</td><td align="center">np.reshape([1,2,3,4],(2,2))</td><td align="center">[[1,2],[3,4]]</td></tr><tr><td align="center">column_stack(arr_1,arr_2)</td><td align="center">按列堆叠数组</td><td align="center">np.column_stack([1,2,3],[4,5,6])</td><td align="center">[[1,4],[2,5],[3,6]]</td></tr><tr><td align="center">save(‘sa.npy’,data)</td><td align="center">保存数组到文件</td><td align="center">np.save(‘sa.npy’,data)</td><td align="center">工作目录生成sa.npy</td></tr><tr><td align="center">load(‘sa.npy’)</td><td align="center">读取数组文件</td><td align="center">np.load(‘sa.npy’)</td><td align="center">读取sa.npy中的数组</td></tr></tbody></table><p><strong>where(condition, x, y)<strong>的</strong>condition</strong>参数是一个<strong>bool</strong>类型的数组(或可以转换为<strong>bool</strong>类型数组的表达式)。它将数组中为<strong>True</strong>的值替换成<strong>x</strong>，将数组中为<strong>False</strong>的值替换为<strong>y</strong>，并在最后返回一个和<strong>condition</strong>同型的数组，常用于将数组中的某些值全部替换成另一种值。比如要把某个数组<strong>arr</strong>中大于5的元素全部替换成0，代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>arr<span class="token operator">&gt;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span></code></pre><p>运行结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922173310355.png" alt="使用where替换元素"></p><p><strong>select(condlist, choicelist, default=0)<strong>适用于需要根据多个条件从不同数组中选择元素的场景。给出一个条件列表，一个选择列表，一个默认值(类似于switch - case)，数组中元素依次判断是否符合</strong>condlist</strong>中的条件，若符合下标为<strong>a</strong>的条件，就将该元素替换成<strong>choicelist</strong>中下标为<strong>a</strong>的元素，若所有条件都不符合则替换成<strong>default</strong>。假设给定一个成绩列表，要对不同分数段给出评级，代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token operator">&lt;</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token punctuation">(</span>arr<span class="token operator">&gt;=</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>arr<span class="token operator">&lt;</span><span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>arr<span class="token operator">&gt;=</span><span class="token number">70</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>arr<span class="token operator">&lt;</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">,</span>arr<span class="token operator">&gt;=</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'不及格'</span><span class="token punctuation">,</span><span class="token string">'及格'</span><span class="token punctuation">,</span><span class="token string">'良好'</span><span class="token punctuation">,</span><span class="token string">'优秀'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token string">'未知'</span><span class="token punctuation">)</span></code></pre><p>运行结果如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922173936938.png" alt="使用select替换元素"></p><p><strong>column_stack(arr_1,arr_2)<strong>不支持广播，使用的条件是</strong>arr_1</strong>和<strong>arr_2</strong>的行数相同。若<strong>arr_1</strong>和<strong>arr_2</strong>是两个一维行向量，则会先转置为一维列向量再堆叠。</p><h2 id="Numpy练习题"><a href="#Numpy练习题" class="headerlink" title="Numpy练习题"></a>Numpy练习题</h2><h3 id="题目一-温度数据分析"><a href="#题目一-温度数据分析" class="headerlink" title="题目一:温度数据分析"></a>题目一:温度数据分析</h3><p>某城市一周的最高气温(°c)为[28,30,29,31,32,30,29]</p><ul><li>计算平均气温、最高气温和最低气温</li><li>找出气温超过30°c的天数</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">temp <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#平均气温</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'平均气温:'</span><span class="token punctuation">,</span><span class="token string">'%.3f'</span><span class="token operator">%</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#最高气温</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'最高气温:'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#最低气温</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'最低气温:'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#气温超过三十度的天数</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'超过三十度的天气(布尔索引):'</span><span class="token punctuation">,</span>temp<span class="token punctuation">[</span>temp <span class="token operator">&gt;</span> <span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'超过三十度的天气(自定义条件):'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>temp<span class="token operator">&gt;</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>temp<span class="token operator">&gt;</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'超过三十度的天气(统计非零方法):'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>count_nonzero<span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>temp<span class="token operator">&gt;</span><span class="token number">30</span><span class="token punctuation">,</span>temp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922174534680.png" alt="题目一输出结果"></p><h3 id="题目二-学生成绩统计"><a href="#题目二-学生成绩统计" class="headerlink" title="题目二:学生成绩统计"></a>题目二:学生成绩统计</h3><p>某班级5名同学的数学成绩为[85,90,78,92,88]</p><ul><li>计算成绩的平均分、中位数、标准差</li><li>将成绩转换为十分制（假设满分为10分）</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">score <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">85</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">,</span><span class="token number">92</span><span class="token punctuation">,</span><span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"平均分:"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"中位数:"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>median<span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"标准差:"</span><span class="token punctuation">,</span><span class="token string">'%.3f'</span><span class="token operator">%</span>np<span class="token punctuation">.</span>std<span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'转换为十分制后成绩为:'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>score <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922174644267.png" alt="题目二输出结果"></p><h3 id="题目三-矩阵运算"><a href="#题目三-矩阵运算" class="headerlink" title="题目三:矩阵运算"></a>题目三:矩阵运算</h3><p>给定矩阵A = [[1,2],[3,4]] 和B = [[5,6],[7,8]]</p><ul><li>计算A + B和A * B（逐元素乘法）</li><li>计算 A 和 B 的矩阵乘法(点积)</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">A <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>B <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"矩阵逐项相加结果为:\n"</span><span class="token punctuation">,</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"矩阵逐项相乘结果为:\n"</span><span class="token punctuation">,</span>A <span class="token operator">*</span> B<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"矩阵乘法结果为:\n"</span><span class="token punctuation">,</span>A @ B<span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922174835576.png" alt="题目三输出结果"></p><h3 id="题目四-随机数据生成"><a href="#题目四-随机数据生成" class="headerlink" title="题目四:随机数据生成"></a>题目四:随机数据生成</h3><p>生成一个(3,4)的随机整数数组，范围[0,10)</p><ul><li>计算每列的最大值和每行的最小值</li><li>将数组中的所有奇数替换为 -1</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#左开右闭</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'每列的最大值:'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#axis = 0代表列，axis = 1代表行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'每行的最小镇:'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'替换后的矩阵为:'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>arr <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922175032656.png" alt="题目四输出结果"></p><h3 id="题目五-数组变形"><a href="#题目五-数组变形" class="headerlink" title="题目五:数组变形"></a>题目五:数组变形</h3><p>创建一个 1 到 12 的一维数组，并转换为(3,4)的二维数组。</p><ul><li>计算每行的和与每列的平均值</li><li>将数组展平为一维数组</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'数组为:'</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'转换后数组为:\n'</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'每行的和为:'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'每列的平均值为:'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>arr<span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'展平为一维数组:'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922175132764.png" alt="题目五输出结果"></p><h3 id="题目六：布尔索引"><a href="#题目六：布尔索引" class="headerlink" title="题目六：布尔索引"></a>题目六：布尔索引</h3><p>生成一个 (5,5) 的随机数组，范围 [0,20)</p><ul><li>找出数组中大于 10 的元素</li><li>将所有大于 10 的元素替换为 0</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"生成的随机数组为:"</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"所有大于10的元素为:"</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>arr<span class="token operator">&gt;</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>arr<span class="token punctuation">[</span>arr <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"替换后的结果为:\n"</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"替换后结果为:\n"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>arr<span class="token operator">&gt;</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="C:/Users/violet796/AppData/Roaming/Typora/typora-user-images/image-20250922175237211.png" alt="题目六输出结果"></p><h3 id="题目七-统计函数应用"><a href="#题目七-统计函数应用" class="headerlink" title="题目七:统计函数应用"></a>题目七:统计函数应用</h3><p>某公司 6 个月的销售额(万元) 为 [120,135,110,125,130,140]</p><ul><li>计算销售额的总和、均值和方差</li><li>找出销售额最高的的月份和最低的月份</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">120</span><span class="token punctuation">,</span><span class="token number">135</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">,</span><span class="token number">125</span><span class="token punctuation">,</span><span class="token number">130</span><span class="token punctuation">,</span><span class="token number">140</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"销售额的总和:"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"销售额的均值:"</span><span class="token punctuation">,</span><span class="token string">'%.3f'</span><span class="token operator">%</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"销售额的方差:"</span><span class="token punctuation">,</span><span class="token string">'%.3f'</span><span class="token operator">%</span>np<span class="token punctuation">.</span>var<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"销售额最高的月份:"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"销售额最低的月份:"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922175405738.png" alt="题目七输出结果"></p><h3 id="题目八-数组拼接"><a href="#题目八-数组拼接" class="headerlink" title="题目八:数组拼接"></a>题目八:数组拼接</h3><p>给定A = [1,2,3] 和B = [4,5,6]</p><ul><li>将 A 和 B 水平拼接为一个新数组</li><li>将 A 和 B 垂直拼接为一个新数组</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">A <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>B <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"水平拼接结果为:\n"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"垂直拼接结果为:\n"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>A<span class="token punctuation">,</span>B<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922175533427.png" alt="题目八输出结果"></p><h3 id="题目九-唯一值与排序"><a href="#题目九-唯一值与排序" class="headerlink" title="题目九:唯一值与排序"></a>题目九:唯一值与排序</h3><p>给定数组[2,1,2,3,1,4,3]</p><ul><li>找出数组中的唯一值并排序</li><li>计算每个唯一值出现的次数</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>u_arr<span class="token punctuation">,</span>counts <span class="token operator">=</span> np<span class="token punctuation">.</span>unique<span class="token punctuation">(</span>arr<span class="token punctuation">,</span>return_counts<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"去重并排序的结果为:"</span><span class="token punctuation">,</span>u_arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"唯一值个数为:"</span><span class="token punctuation">,</span>counts<span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922175631895.png" alt="题目九输出结果"></p><h3 id="题目十-缺失值处理"><a href="#题目十-缺失值处理" class="headerlink" title="题目十:缺失值处理"></a>题目十:缺失值处理</h3><p>给定数组[1,np.nan,3,np.nan,5]</p><ul><li>计算数组中缺失值的数量</li><li>将缺失值替换为0</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数组缺失值数量为:"</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>size<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'替换后数组结果为:'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922175721037.png" alt="题目十输出结果"></p><h3 id="题目十一-三角函数计算"><a href="#题目十一-三角函数计算" class="headerlink" title="题目十一:三角函数计算"></a>题目十一:三角函数计算</h3><p>生成一个包含 0 到 Π 的等间隔数组(包含五个数)</p><ul><li>计算数组中每个数的正弦值和余弦值</li><li>将结果保存为一个二位数组，第一列为正弦值，第二列为余弦值</li></ul><p>解题代码如下:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matharr <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>math<span class="token punctuation">.</span>pi<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>s_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>c_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'保存答案的二维数组为:\n'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>column_stack<span class="token punctuation">(</span><span class="token punctuation">(</span>s_arr<span class="token punctuation">,</span>c_arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果如下:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250922175805110.png" alt="题目十一输出结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Numpy</strong>是一个极其强大的库，合理运用上文中的方法，可以极大提高数据运算与统计的效率。</p>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hot100:三数之和</title>
      <link href="/2025/09/14/hot100-san-shu-zhi-he/"/>
      <url>/2025/09/14/hot100-san-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode.cn/problems/3sum/" title="三数之和">Hot100 - LeetCode15:三数之和</a></p><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><h2 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h2><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。</code></pre><h2 id="题目规模"><a href="#题目规模" class="headerlink" title="题目规模"></a>题目规模</h2><ul><li>3 &lt;= nums.length &lt;= 3000</li><li>-10^5 &lt;= nums[i] &lt;= 10^5</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要找的是满足条件的三元组，且三元组当中为具体的值，故数组的下标并不重要，排序不会影响最后的结果，可以先排序。</p><p>要找三个数组下标i,j,k，使得：<br>$$<br>nums[i] + nums[j] + nums[k] = 0<br>$$<br>可以依次固定数组中的每一个数，再从该数的右边找到两个数，使其相加满足条件，这样就将题目转换成了target为nums[i]的两数之和，如图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250914224213937.png" alt="演示图片"></p><p>具体的实现思路如下:</p><ul><li><p>从左往右遍历排序后的数组，将当前遍历到的值固定，记指针为<strong>i</strong></p></li><li><p>从子数组[i + 1,len(nums) - 1]中找到两个指针<strong>j</strong>、<strong>k</strong>,使得:<br>$$<br>nums[j] + nums[k]  = -nums[i]<br>$$</p></li></ul><p>排序后的数组具有单调性：</p><ul><li>当<em>nums[i] + nums[j] + nums[k] &lt; 0</em>时，需要整体值增加，右移<strong>j指针</strong></li><li>当<em>nums[i] + nums[j] + nums[k] &gt; 0</em>时，需要整体值减小，左移<strong>k指针</strong></li><li>当<em>nums[i] + nums[j] + nums[k]  = 0</em>时，找到了一组可行的答案，进入下列步骤</li></ul><p>由于题目要求答案中不可以包含重复的三元组，故<strong>每一次遍历前</strong>和<strong>找到符合题意的解后</strong>还需要将指针移动到特定的位置，具体的步骤如下:</p><ul><li>在遍历前，若当前固定值和上一个固定值相同，可以直接跳过这次遍历</li><li>找到符合题意的答案后，将<strong>j</strong>和<strong>k</strong>分别移动到与当前指向元素不同的的第一个元素</li></ul><p>总结排序后的两步:</p><p>1.依次固定每个值，将题目转换为两数之和，从当前固定值之后找到两个元素，使其形成符合题意的三元组</p><p>2.通过移动指针进行去重操作</p><p>循环上述两步即可找到所有答案。</p><h2 id="思路补充"><a href="#思路补充" class="headerlink" title="思路补充"></a>思路补充</h2><p>Q：<strong>为什么只用从当前固定值的右边找两个元素，而不用再从左边找了?</strong></p><p>A：因为在之前的遍历中就已经把所有包含左边元素的解加入到了答案列表。</p><p>Q：<strong>为什么找到符合题意的答案后，要将<em>j</em>和<em>k</em>分别移动到与当前指向元素不同的的第一个元素？</strong></p><p>A：对于数组[a,b,b,c,e,d,d]，设有 <strong>a + b + d  = 0</strong>，若仅仅只是简单移动两个指针，将会重复加入答案[a,b,d]，故需要将两个指针分别移动到c和e，以确保不会重复。</p><p>Q：<strong>在遍历前，若当前固定值和上一个固定值相同，可以直接跳过这次遍历？</strong></p><p>A：由于数组已经排序完毕，故相同的元素将会挨在一起。假设存在重复元素<strong>a</strong>，当固定到第一个<strong>a</strong>时，由于是从其之后找剩下两个符合题意的元素，此时分为两种情况：</p><ul><li><p>三元组只包含一个a。</p></li><li><p>三元组包含多个a。若a不等于0，则三元组最多包含两个a</p></li></ul><p>对于第一种情况，将第一个a之后的其它a当作固定值，得到的答案和第一个a当作固定值的答案是完全相同的。</p><p>对于第二种情况，将第一个a之后的其它a当作固定值，得到的答案可能会因为在它之后a的数量不够，而少了一种或两种解。</p><p>换言之，无论是哪种情况，<strong>将之后的a当作固定值得到的答案的集合</strong>只不过是<strong>将第一个a当作固定值得到的答案的集合</strong>的子集罢了，故可以直接跳过重复值的遍历。</p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#如果最小的三个数的和都大于0，那么无解</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment">#如果最大的三个数的和都小于0，那么无解</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment">#固定到len(nums) - 2，因为最后两个元素凑不出三元组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#重复元素直接跳过判断</span>            <span class="token keyword">if</span> i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            k <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token comment">#转为两数之和</span>            <span class="token keyword">while</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>                <span class="token comment">#说明小了</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    j <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#说明大了</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    k <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token comment">#找到和左指针相同的最后一个元素</span>                    <span class="token keyword">while</span> j <span class="token operator">&lt;</span> k <span class="token keyword">and</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                        j <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token comment">#找到和右指针相同的最后一个元素</span>                    <span class="token keyword">while</span> j <span class="token operator">&lt;</span> k <span class="token keyword">and</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>                        k <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token comment">#移动到不同元素的位置</span>                    j <span class="token operator">+=</span> <span class="token number">1</span>                    k <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans    </code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O（n²）。每次循环遍历的长度和为<br>$$<br>（n - 1） +（ n - 2） +（ n - 3） +…. + 2，<br>$$</li></ul><p>故时间复杂度为O（n²）。</p><ul><li>空间复杂度：O（1）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hot100 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法:滑动窗口类型题目总结</title>
      <link href="/2025/08/26/suan-fa-hua-dong-chuang-kou-lei-xing-ti-mu-zong-jie/"/>
      <url>/2025/08/26/suan-fa-hua-dong-chuang-kou-lei-xing-ti-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是滑动窗口"><a href="#什么是滑动窗口" class="headerlink" title="什么是滑动窗口"></a>什么是滑动窗口</h1><p>滑动窗口是算法题当中一种常见的解题方法，属于双指针的一种，常用于数据结构为数组（列表）、字符串类型的题目。其目的在于通过维护两个指针left、right，并将left和right当作题目给出数组（列表）、字符串中的一个子数组（列表）、字符串的左右端点，通过不断增大两指针的值，使得由两指针维护的窗口始终满足题目所给要求，最后计算答案。</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250826162157075.png" alt="一个符合题意的最大窗口"></p><p>如上图所示，在算法刚开始执行时窗口会先不断扩大，此时可以确保由left指向的a0作为左端点和right指向的a3作为右端点所构成的窗口是符合题意的。假设当窗口继续扩大，即right继续右移指向a4时，窗口不再满足题目要求，这个时候就需要通过右移left指向新的元素使得窗口缩小，以重新满足题目要求。假设当left指向a2时，由两指针构成的窗口可重新满足题意，如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250826163339407.png" alt="重新满足题意的窗口"></p><p>这样由a2到a4构成的新的窗口又重新满足了题意。最后只需根据题目要求，计算答案的个数即可。由于移动两个指针的过程就像是一个窗口在移动，故得名为滑动窗口。而定长滑动窗口则又是滑动窗口的一个特殊形式，它的窗口大小是固定的，也就是窗口的左右端点需要一起移动，在后文中会对定长滑动窗口进行举例介绍。双指针、滑动窗口、定长滑动窗口的关系如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250826164144380.png" alt="三者关系"></p><p>双指针是最基础的方法，滑动窗口是双指针的应用，定长滑动窗口是一种特殊的滑动窗口。</p><h1 id="滑动窗口的使用场景"><a href="#滑动窗口的使用场景" class="headerlink" title="滑动窗口的使用场景"></a>滑动窗口的使用场景</h1><p>当一道题目能用 <strong>滑动窗口解决</strong> 时，它一般符合以下三个特征：</p><ul><li>题目背景的数据结构为数组（列表）、字符串</li><li>题目需要求 “满足条件的子数组（列表）、子字符串个数”，或 “满足条件的子数组（列表）、子字符串的最大长度或个数”</li><li>滑动窗口适用的题目往往具有 <strong>单调性</strong></li></ul><p>对第三点做进一步说明：当窗口扩张时，窗口整体与题目条件的关系会呈现出一定的单调性：要么越容易满足条件（例如要求子数组和大于某个值 <em>k</em>，且数组元素为非负数时），要么越不容易满足条件。一旦窗口失去题意，就可以通过移动左指针缩小窗口来重新满足条件。这种单调性是滑动窗口能够高效发挥作用的关键。</p><p>当一道题目能使用更特别的 <strong>定长滑动窗口</strong> 时，除了符合上述的第一点，还应当满足以下特征：</p><ul><li>题目明确说明需要找一个大小为<em>k</em>的子数组（列表）、字符串，使其满足题目条件</li><li>题目要求在固定大小的窗口上进行统计或优化，例如 “统计该窗口内某类元素的个数”，或 “计算和、最大值、平均值等”</li></ul><p>相比一般滑动窗口，由于定长滑动窗口固定了窗口大小，寻找子数组的过程中无论结果如何左右指针都会一起移动，本身就不会回溯，故定长滑动窗口的使用对单调性并无要求，但其使用场景更为局限，判断条件更直观明确。</p><p><img src="http://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250827213223761.png" alt="有无单调性的数组对比"></p><p>普通滑动窗口能否使用的核心，仍然在于题目是否具有单调性。以找到元素和大于<em>k</em>的子数组为例：通过第一小节<strong>什么是滑动窗口</strong>我们知道，当窗口不满足条件时，右指针会右移使得窗口逐渐满足条件。对于上图中具有单调性的数组，随着指针不断右移，子数组将越来越符合条件，因为它每次都是增加一个正数，使得子数组和越来越接近<em>k</em>。而不含单调性的数组随着指针右移，它有时因为加了一个正数，使得子数组和离<em>k</em>越接近，但有时候又因为加了一个负数使得子数组和离<em>k</em>越遥远，这就是不含有单调性的具体体现。</p><p>关于单调性的必需的原因，将在下一节中介绍。</p><h1 id="一般滑动窗口的原理"><a href="#一般滑动窗口的原理" class="headerlink" title="一般滑动窗口的原理"></a>一般滑动窗口的原理</h1><blockquote><p><em>注:本小节若无特别说明，提到的滑动窗口指的均是一般滑动窗口，而非定长滑动窗口</em></p></blockquote><p>在介绍单调性对于使用一般滑动窗口的必要性之前，首先介绍滑动窗口的本质。</p><p>滑动窗口的本质实际上是对暴力解法的一种<strong>剪枝</strong>，也就是利用滑动窗口省去很大一部分不必要的判断。当我们需要找到一个数组的子数组，使其满足某种条件并统计个数或者返回需要满足的条件的值时，暴力解法是遍历这个数组当中的所有子数组，分别判断是否符合题意并记录结果，具体的解题伪代码如下:<br></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">Brute_Force</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        暴力法        nums为待遍历数组        """</span>        ans <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">#用来记录答案</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> meets the condition<span class="token punctuation">:</span>                    ans <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>不难判断暴力解法的时间复杂度为O（n²）。</p><p>当题目给出的数组<em>nums</em>具有单调性时，也就是要么子数组越长越容易满足条件要么子数组越短越容易满足条件，就可以省去很多不必要的判断，使得左右指针只用向一个方向移动，无需回溯。下文分别称这两种情况为越长越合法和越短越合法。当给出数组<em>nums</em>具有单调性时，一般会有以下<strong>两条性质</strong>:</p><ul><li>若由left 和 right构成的窗口不符合题意，那么由left 和 right + 1、right + 2、right + 3….len（<em>nums</em>） - 1 构成的窗口依然不符合题意</li><li>若由left 和 right构成的窗口符合题意,那么由left + 1、left + 2…..right 和 right 构成的窗口依然符合题意</li></ul><blockquote><p>注:上述两条性质适用于单调性为越短越合法的题目，对于单调性为越长越合法的题目，需将第一条性质中的两个不符合改为符合，将第二条性质中的符合改为不符合。*</p></blockquote><p>对于单调性为越短越合法的题目而言，子数组越大，该子数组就越不满足题目要求，如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250828102434545.png" alt="对性质一进行解释"></p><p>假设由left,right两指针构成的窗口<strong>恰好</strong>此时不满足条件了，由于单调性为越短越合法，也就是当窗口越大时，反而越不满足条件，那么由left和right之后的元素构成的窗口自然也是不满足条件的，之后就不用再进行判断了，这即为上述性质一。</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250828103312415.png" alt="对性质二进行解释"></p><p>如上图，假设由left和right构成的窗口此时是满足条件的，由于数组越短越合法，则从left到right之间的所有元素和right构成的窗口都是满足条件的，在后续又可以省去这一部分的判断，这即为上述性质二。</p><p>正如前文所说，滑动窗口类型的题目，left和right两个指针只会向同一个地方移动，绝不回溯，这正是因为题目具有单调性，两个指针的作用分别如下:</p><ul><li>右指针:负责扩大窗口使窗口不断满足题意，但在扩大窗口的过程中可能会由于新加入窗口的元素过大等原因，使得窗口不再满足题意</li><li>左指针:负责缩小窗口使窗口重新满足题意</li></ul><p>过程中左指针无需回溯可以理解成: 随着右指针的移动，窗口越来越大，直至不满足条件，左指针<strong>通过右移</strong>使其<strong>重新满足条件</strong>。如果左指针回溯到开始的位置重新遍历形成了一个大窗口，那么那段不符合题意的小窗口也依然包含在了这个大窗口中，由于越短越合法，故此时这个大窗口<strong>一定是不合法</strong>的，无需再进行判断。也就是说，<strong>性质一</strong>确保了左指针无需再回溯，只用从当前位置开始继续遍历。</p><p>过程中右指针无需回溯可以理解成: 当左指针发生了移动，说明此时右指针<strong>恰好停留在使得窗口不满足条件的位置</strong>，也就是当前右指针所指向位置的前一个元素，和先前的左指针以及两指针中间的元素所构成的窗口<strong>均合法</strong>，故右指针无需再回溯来判断它与当前左指针构成的新窗口是否依然合法，这是由上述<strong>性质二</strong>确保的。</p><p>越长越合法类型的滑动窗口同理。</p><p>滑动窗口的解题模板大致如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">sliding_windows</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        滑动窗口        """</span>        left <span class="token operator">=</span> ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#根据题目条件</span>            <span class="token comment">#计算需要的值</span>            <span class="token keyword">while</span> ans <span class="token keyword">not</span> meets the condition<span class="token punctuation">:</span>                <span class="token comment">#用计算出来的值</span>                <span class="token comment">#减去左指针指向的值</span>                left <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment">#左指针右移</span>            ans <span class="token operator">+=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">#越短越合法类型</span>            ans <span class="token operator">+=</span> left <span class="token comment">#越长越合法类型</span>        <span class="token keyword">return</span> ans</code></pre><p>由于外层循环是right不断右移直至数组的末尾，内层循环是left不断右移（不回溯）直至数组的末尾，每个数组元素<strong>最多被操作两次</strong>（一次进窗口、一次出窗口）。故时间复杂度为O（2n），省略常数项，滑动窗口的时间复杂度可以达到<strong>O（n）</strong>。</p><p>最后介绍单调性的必要性。倘若此时题目给出的数组不具有单调性，即有正有负。以找和小于<em>k</em>的子数组为例，假设在一个负数元素之前的所有元素均为正数，那么当该元素进入窗口时，它缩小了子数组的和，这就使得和小于<em>k</em>的子数组可能会<strong>出现在以当前left左边的元素为左端点的窗口中</strong>，如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250828111059431.png" alt="找到和<=4的子数组个数"></p><p>当*-5<em>进入窗口并作为窗口的右端点时，通过上文的分析我们知道，若具有单调性，由于*<em>性质一</em></em>，left不必回溯。但对于这种不具有单调性的情况，当*-5*进入窗口时，left指向下标为0的元素1，此时新窗口依然符合题意，也就是左指针此时需要回溯，并未达到节省时间复杂度的目的，不符合滑动窗口的逻辑，故不能使用滑动窗口，这也解释了为什么单调性是使用滑动窗口的必要条件。</p><h1 id="定长滑动窗口"><a href="#定长滑动窗口" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h1><p>定长滑动窗口是一种特殊的滑动窗口，常用在给定一个数组（列表）、字符串，寻找一个大小为<em>k</em>的子数组(列表)、字符串，使其满足“窗口和最大”、”窗口平均值最大”、”窗口内某元素数量最多”等条件。</p><p>以数组<em>nums</em>为例，由于<em>nums</em>中长度为<em>k</em>的子数组个数固定为<em>len（nums） - k + 1</em>，定长滑动窗口<strong>无论当前窗口结果</strong>如何，左右指针都要进行一次的移动来找到下一个窗口，也就是说，对于一个新的窗口而言，它与前一个窗口的区别在于首尾两个元素，如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250829094935530.png" alt="定长滑动窗口示例"></p><p>从窗口1变换为窗口2，left指针指向的元素出窗口，right’指针指向的元素进入窗口，也就是只要将统计值减去left指针指向元素带来的影响，再加上right’指针指向元素带来的影响，得到的就是新的窗口的统计值，再利用新窗口的统计值和当前最优统计值进行对比，找到最满足题意的统计值，记录并返回即可。</p><p>定长滑动窗口的三步曲如下:</p><ul><li>构建一个大小为<em>k</em>的窗口</li><li>记录当前窗口的统计值（如:窗口元素和、窗口元素平均值、窗口内某元素的个数）</li><li>统计值减去左指针指向值带来的影响，左指针右移、统计值加上右指针指向值带来的影响，右指针右移</li></ul><p>又由于窗口大小固定为<em>k</em>，故<em>left</em>指针指向的元素和<em>right</em>指针指向的元素有如下关系:<br>$$<br>left = right - k + 1<br>$$<br>因为<em>right</em>为大小为<em>k</em>的窗口的右端点，除去<em>right</em>指向元素以外，还需往前数<em>k-1</em> 个元素才到<em>left</em>指向元素，故实际上:<br>$$<br>left = right - (k - 1) = right - k + 1<br>$$<br>所以在实际的解题过程中，无需再定义一个左指针<em>left</em>，可直接用上述公式得到<em>left</em>所指向元素。</p><p>重复以上第二和第三步，直到统计完所有结果为止。</p><p>定长滑动窗口解题的伪代码如下:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fixed_size_sliding_windows</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">,</span>k<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        定长滑动窗口        k为窗口大小        nums为待进行寻找答案的列表        """</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> alllist        ans <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#1.构建窗口</span>            res <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>             <span class="token keyword">if</span> right <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                 <span class="token keyword">continue</span>            <span class="token comment">#2.记录窗口统计值，并与当前最优解比较</span>            ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>res<span class="token punctuation">)</span>            <span class="token comment">#3.统计值减去最左边元素带来的影响</span>            res <span class="token operator">-=</span> nums<span class="token punctuation">[</span>right <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>          <span class="token keyword">return</span> ans</code></pre><h1 id="滑动窗口例题"><a href="#滑动窗口例题" class="headerlink" title="滑动窗口例题"></a>滑动窗口例题</h1><h2 id="定长滑动窗口-1"><a href="#定长滑动窗口-1" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h2><p>定长滑动窗口的题目类型一般分为以下两种:</p><ul><li>找到大小为<em>k</em>的子数组，使其具有最大、最小的元素和等</li><li>找到大小为<em>k</em>的子数组，使子数组内某元素的个数最小或最大</li></ul><p>不管题目描述如何改变，最后都可以转化为上述两种类型。</p><blockquote><p><em>下文举例介绍定长滑动窗口</em></p></blockquote><p><strong>1.定长子串中元音的最大数</strong></p><p>题目链接：<a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/" title="定长子串中元音的最大数">1456.定长子串中元音的最大数</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给你字符串 s 和整数 k 。请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。英文中的 元音字母 为（a, e, i, o, u）。</code></pre><p>输入输出示例</p><pre class="language-none"><code class="language-none">示例 1：输入：s = "abciiidef", k = 3输出：3解释：子字符串 "iii" 包含 3 个元音字母。示例 2：输入：s = "aeiou", k = 2输出：2解释：任意长度为 2 的子字符串都包含 2 个元音字母。示例 3：输入：s = "leetcode", k = 3输出：2解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。示例 4：输入：s = "rhythms", k = 4输出：0解释：字符串 s 中不含任何元音字母。示例 5：输入：s = "tryhard", k = 4输出：1</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= s.length &lt;= 10^5s 由小写英文字母组成1 &lt;= k &lt;= s.length</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">这道题属于典型的定长滑动窗口类型二，给定一个大小为k的窗口，找到包含元音数量最多的那个窗口并返回结果。只需按照三部曲：1.构建第一个窗口并在该过程中统计元音个数2.将当前窗口的元音个数和当前最优解比较3.判断left指向的元素和right + 1指向的元素是否为元音字母，并作出相应操作具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxVowels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        定长滑动窗口        """</span>        vowels <span class="token operator">=</span> <span class="token string">'aeiou'</span> <span class="token comment">#记录元音字母</span>        ans <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment">#ans是返回值，res是临时变量</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#1.统计第一个窗口元音个数</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> right <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token comment">#2.和当前最优解比较</span>            ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>ans<span class="token punctuation">)</span>            <span class="token comment">#3.判断左指针指向元素的性质，并移动左指针</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>right <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                res <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li>时间复杂度:O（n）</li><li>空间复杂度:O（1）</li></ul><p><strong>2.可获得的最大点数</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/" title="可获得的最大点数">1423. 可获得的最大点数 </a></p><p>题目描述：</p><pre class="language-none"><code class="language-none">几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。你的点数就是你拿到手中的所有卡牌的点数之和。给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</code></pre><p>输入输出示例；</p><pre class="language-none"><code class="language-none">示例 1：输入：cardPoints = [1,2,3,4,5,6,1], k = 3输出：12解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。示例 2：输入：cardPoints = [2,2,2], k = 2输出：4解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。示例 3：输入：cardPoints = [9,7,7,9,7,7,9], k = 7输出：55解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。示例 4：输入：cardPoints = [1,1000,1], k = 1输出：1解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5：输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3输出：202</code></pre><p>题目规模：</p><pre class="language-none"><code class="language-none">1 &lt;= cardPoints.length &lt;= 10^51 &lt;= cardPoints[i] &lt;= 10^41 &lt;= k &lt;= cardPoints.length</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">这道题则对应定长滑动窗口题目的类型一，只不过需要用到逆向思维。由于抽牌只能从cardPoints的左右两边抽，并且只能抽k张，也就是最后牌组里会剩下len(cardPoints) - k张牌，且这k张牌是连续的。那么题目就变成了：从cardPoints中找到一个大小为len(cardPoints) - k的子数组，使得这个子数组的元素和最小。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxScore</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cardPoints<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        定长滑动窗口        窗口为0的话需要特判        """</span>        l <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span> <span class="token operator">-</span> k <span class="token comment">#逆向思维的窗口大小</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span>        ans<span class="token punctuation">,</span>res <span class="token operator">=</span><span class="token builtin">sum</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token comment">#ans记录答案，res记录中间值</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#1.构建窗口并记录值</span>            res <span class="token operator">+=</span> cardPoints<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            <span class="token keyword">if</span> right <span class="token operator">&lt;</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token comment">#2.与当前最优解比较</span>            ans <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>res<span class="token punctuation">)</span>            <span class="token comment">#3.移除左指针指向元素</span>            res <span class="token operator">-=</span> cardPoints<span class="token punctuation">[</span>right <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span> <span class="token operator">-</span> ans</code></pre><p>当窗口大小为0时需要特判。因为<em>res</em>减去的是窗口最左边的元素，如果一个窗口大小为0的话，那它将不存在所谓最左边的元素，代入进倒数第二行，当<em>right = len(cardPoints) - 1</em>时将会越界。</p><p>复杂度分析:</p><ul><li><p>时间复杂度:O（n）</p></li><li><p>空间复杂度:O（1）</p></li></ul><h2 id="不定长滑动窗口"><a href="#不定长滑动窗口" class="headerlink" title="不定长滑动窗口"></a>不定长滑动窗口</h2><p>不定长滑动窗口对题目有着严格的单调性要求，一般分为以下几种类型：</p><ul><li>越短越合法求最长的子数组</li><li>越长越合法求最短的子数组</li><li>求子数组的个数</li></ul><p>其中求子数组的个数又可以分为：</p><ul><li>求某值大于<em>k</em>的子数组个数</li><li>求某值小于<em>k</em>的子数组个数</li><li>求某值恰好等于<em>k</em>的子数组个数</li></ul><p>对于不定长滑动窗口，不管题目描述如何改变，大部分都能够转换为以上几种类型</p><blockquote><p><em>下文举例介绍不定长滑动窗口</em></p></blockquote><p><strong>1.无重复字符的最长子串</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/" title="无重复字符的最长子串">3. 无重复字符的最长子串</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1:输入: s = "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。示例 2:输入: s = "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。示例 3:输入: s = "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">0 &lt;= s.length &lt;= 5 * 104s 由英文字母、数字、符号和空格组成</code></pre><p>解题思路：</p><pre class="language-none"><code class="language-none">这是一道很经典的具有单调性的题目。子字符串越长，子字符串含有的字符就越多，含有重复字符的概率就越大，越不符合题意。可以判断这是一道越短越合法类型的题目，故可以采用滑动窗口。利用"滑动窗口的原理"小节中介绍的滑动窗口的两条性质，可以有效剪枝。具体代码如下。left不用回溯:越短越合法，回溯的话相当于依然包含了不合法子字符串right不用回溯:由于当right移动到不符合题意的位置时，left会移动使其重新符合题意。也就是在统计时，当前的窗口正是以当前right为右指针所构成的最大的能满足题意的窗口</code></pre><p>解题代码</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        不定长滑动窗口        越短越合法，求个数        """</span>        left <span class="token operator">=</span> ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment">#定义一个字典c来记录每个答案的个数</span>        c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#如果不符合题意了，就移动左指针让其重新符合题意</span>            <span class="token keyword">while</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>                c<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#每一次符合题意的子字符串长度都是right - left + 1</span>            ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li><p>时间复杂度:O（n）</p></li><li><p>空间复杂度:O（1）字符集大小为128，c的最大长度即为128，省略常数项，即为O（1）</p></li></ul><p><strong>2.将x减到0的最小操作数</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/" title="将x减到0的最小操作数">1658.将x减到0的最小操作数</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：nums = [1,1,4,2,3], x = 5输出：2解释：最佳解决方案是移除后两个元素，将 x 减到 0 。示例 2：输入：nums = [5,6,7,8,9], x = 4输出：-1示例 3：输入：nums = [3,2,20,1,1,3], x = 10输出：5解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= nums.length &lt;= 1051 &lt;= nums[i] &lt;= 1041 &lt;= x &lt;= 109</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">同定长滑动窗口例题2一样，这道题目依然可以利用逆向思维，将题目改写成:找到最大连续的子数组k，使其和为sum(nums) - x，如果存在,返回len(sums) - len(k)，否则返回-1判断题目的单调性。由于数组元素均为正数，当子数组越长，子数组和就越大，越不符合题意，故可以使用滑动窗口解决。但此时还应注意一种情况，由于此题采用的是逆向思维，按照前文，若当前窗口不符合题意，则需要移动左指针使其重新符合题意记要求的和为 i = sum(nums) - x，当前子数组和为j，则当j &gt; i时需要重新移动left但如果i＜0，即数组所有元素加起来的和也小于x，由于数组元素均为正数，无论怎么移动left指针，j &gt; i一定成立，此时会进入死循环。故需要特判这种情况，直接返回-1.具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minOperations</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        逆向思维        不定长滑动窗口        子数组越短越合法        """</span>        <span class="token comment">#特判所有元素不够加的情况</span>        <span class="token keyword">if</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&lt;</span> x<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span> <span class="token number">1</span>        ans <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token comment">#i为窗口要找的值</span>        i <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> x        left <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>j <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> j            <span class="token keyword">while</span> res <span class="token operator">&gt;</span> i<span class="token punctuation">:</span>                res <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#符合条件才记录答案</span>            <span class="token keyword">if</span> res <span class="token operator">==</span> i<span class="token punctuation">:</span>                ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>right <span class="token operator">-</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">#如果题目当中没有符合题意的子数组，ans = -1，直接返回-1，否则返回除去ans外剩下的元素长度</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> ans <span class="token keyword">if</span> ans <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token operator">-</span> <span class="token number">1</span></code></pre><p>复杂度分析:</p><ul><li><p>时间复杂度：O（n)</p></li><li><p>空间复杂度：O（1）</p></li></ul><p><strong>3.最小覆盖字串</strong></p><p>题目链接：<a href="https://leetcode.cn/problems/minimum-window-substring/submissions/657830960/" title="最小覆盖子串">76. 最小覆盖子串</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：s = "ADOBECODEBANC", t = "ABC"输出："BANC"解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。示例 2：输入：s = "a", t = "a"输出："a"解释：整个字符串 s 是最小覆盖子串。示例 3:输入: s = "a", t = "aa"输出: ""解释: t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</code></pre><p>题目规模：</p><pre class="language-none"><code class="language-none">m == s.lengthn == t.length1 &lt;= m, n &lt;= 105s 和 t 由英文字母组成</code></pre><p>解题思路：</p><pre class="language-none"><code class="language-none">首先明白覆盖的含义。当S的子字符串中的对应字符个数大于等于t中对应的字符个数，此时就说子字符串覆盖了t。再来看单调性，当S的子字符串越长，里面的字符就越多，就越有可能包括所有t中出现的字符串，故这是一道越长越合法类型的题目。在此基础上求最短的符合条件的子字符串。同理，先让窗口逐渐扩大，直到其符合条件。当其符合条件时，当前right指针指向的元素之后的所有元素与当前left指针指向元素所构成的窗口均符合题意，但长度不是最小，故由性质一进行剪枝，无需再判断。而Counter()可以很方便的的判断字符串中的字符个数并进行比较。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        越长越合法求最短        """</span>        c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>        d <span class="token operator">=</span> Counter<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        left<span class="token punctuation">,</span>cnt<span class="token punctuation">,</span>ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token string">""</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#此时覆盖了t字符串</span>            <span class="token keyword">while</span> c <span class="token operator">&gt;=</span> d<span class="token punctuation">:</span>                <span class="token keyword">if</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> cnt<span class="token punctuation">:</span>                    ans <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>                    cnt <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span>                c<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li><p>时间复杂度:O（<em>|Σ|·|s| + |t|</em>） <code>while c &gt;= d</code> 的条件在每次 <code>right</code> 移动时会判断一次（≤|s| 次），并且每次 <code>left</code> 移动也会导致一次判断（<code>left</code> 全程最多移动 ≤|s| 次），所以条件判断总次数 ≤ 2|s|，每次判断代价为 <code>O(|Σ|)</code>，再加上构造 <code>Counter(t)</code> 的 <code>O(|t|)</code>。当 |Σ| 为常数（如本题 52 个字母）时，复杂度可简化为 <code>O(|s| + |t|)</code>。</p></li><li><p>空间复杂度:O（1） 由于s和t均由英文字母构成，c和d大小最多为52，和为104，故空间复杂度为常数。</p></li></ul><p><strong>4.不间断子数组</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/continuous-subarrays/" title="不间断子数组">2762. 不间断子数组 </a></p><p>题目描述：</p><pre class="language-none"><code class="language-none">给你一个下标从 0 开始的整数数组 nums 。nums 的一个子数组如果满足以下条件，那么它是 不间断 的：i，i + 1 ，...，j  表示子数组中的下标。对于所有满足 i &lt;= i1, i2 &lt;= j 的下标对，都有 0 &lt;= |nums[i1] - nums[i2]| &lt;= 2 。请你返回 不间断 子数组的总数目。子数组是一个数组中一段连续 非空 的元素序列。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：nums = [5,4,2,4]输出：8解释：大小为 1 的不间断子数组：[5], [4], [2], [4] 。大小为 2 的不间断子数组：[5,4], [4,2], [2,4] 。大小为 3 的不间断子数组：[4,2,4] 。没有大小为 4 的不间断子数组。不间断子数组的总数目为 4 + 3 + 1 = 8 。除了这些以外，没有别的不间断子数组。示例 2：输入：nums = [1,2,3]输出：6解释：大小为 1 的不间断子数组：[1], [2], [3] 。大小为 2 的不间断子数组：[1,2], [2,3] 。大小为 3 的不间断子数组：[1,2,3] 。不间断子数组的总数目为 3 + 2 + 1 = 6 。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= nums.length &lt;= 1051 &lt;= nums[i] &lt;= 109</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">首先判断题目意思，找到一个子数组，使其中任意两个元素的差的绝对值均小于等于2。这等价于，找到一个子数组，使得该子数组中最大的元素和最小的元素差值小于等于2。再来判断题目的单调性，当子数组内元素越多，子数组中最大和最小的元素差就可能越大，就越不合法。故这是一个越短越合法类型的题目。题目要求统计合法的子数组个数，只需要每次统计时加上right - left + 1即可。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">continuousSubarrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        越短越合法        求数组个数        """</span>        left <span class="token operator">=</span> ans <span class="token operator">=</span> <span class="token number">0</span>        c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">#记录当前窗口的元素</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#如果不符合题意，就让它变成符合题意为止</span>            <span class="token keyword">while</span> <span class="token builtin">max</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">min</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">:</span>                c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                  <span class="token keyword">del</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            ans <span class="token operator">+=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li><p>时间复杂度:O（n）</p><p>将题目要求的差值设为M，即：<br>$$<br>0 &lt;= nums[i] - nums[j] &lt;= M(0 &lt;= i &lt;= j &lt;= len(nums) - 1)<br>$$<br>则时间复杂度为O（（M+1）n），其中n为数组的长度，原因如下：</p><p>每一次left指针的移动都伴随着<br>$$<br>max(c) - min(c)<br>$$<br>而字典调用这两个方法的逻辑是遍历整个字典，寻找最大的键。<strong>由于题目要求子数组内差值两两之间不能超过M，故最多有M + 1个元素会被存入字典中</strong>，max和min两个方法遍历的最坏情况也就是遍历M + 1个元素。而left最多移动n次，故时间复杂度是O（（M+1）n）。</p><p>而对于本题，M＝2，代入并省略常数项可得时间复杂度为O（n）。</p></li><li><p>空间复杂度:O（1）</p><p>空间复杂度即为定义的c的最大长度，理由同上。</p></li></ul><p>​故空间复杂度最大为O（M + 1）。对于本题，M＝2，代入并省略常数项可得空间复杂度为O（1）。</p><p>Q&amp;A：</p><p>Q:为什么子数组中最大的元素和最小的元素差值小于等于2即可满足条件?</p><p>A:可以看成一根数轴，子数组的最大和最小元素分别对应数轴两端，其余元素全在该数轴内，差的绝对值自然小于等于2.</p><p>Q:为什么统计时加上right - left + 1即可？</p><p>A:经过分析可知，该题目为越短越合法类型。由性质二可得，对于一个由left,right构成的窗口，如果它满足题意，那么从left到right之间（包含left和right）的所有元素和right构成的窗口均符合题意，这里一共有right - left + 1个元素，即有right - left + 1个合法子数组。而在统计时，对于每一个right，均能确保left在恰好使得窗口满足题意的位置，故直接加上right - left + 1即可。</p><p><strong>5.统计好子数组的数目</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/count-the-number-of-good-subarrays/description/" title="统计好子数组的数目">2537. 统计好子数组的数目 </a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i &lt; j 且 arr[i] == arr[j] ，那么称它是一个 好 子数组。子数组 是原数组中一段连续 非空 的元素序列。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：nums = [1,1,1,1,1], k = 10输出：1解释：唯一的好子数组是这个数组本身。示例 2：输入：nums = [3,1,4,3,2,2,4], k = 2输出：4解释：总共有 4 个不同的好子数组：- [3,1,4,3,2,2] 有 2 对。- [3,1,4,3,2,2,4] 有 3 对。- [1,4,3,2,2,4] 有 2 对。- [4,3,2,2,4] 有 2 对。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= nums.length &lt;= 1051 &lt;= nums[i], k &lt;= 109</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">首先分析题目意思，有k对元素相同，那就为一个好子数组，求子数组个数。即，找到子数组使其相同元素下标对数大于等于k，这是一个越长越合法求个数的问题。当子数组越大，子数组内元素就越多，相同元素出现的概率就越大，越可能满足题意。符合单调性，可以使用滑动窗口。对于每一个加入进窗口的元素，假设窗口内有k个该元素，那么相同元素对数结果需要加k。而在每次统计时，答案加left 即为”以当前right指针指向元素“作为数组右端点的满足题意的子数组个数。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countGood</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        越长越合法        求合法子数组个数        """</span>        c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">#记录窗口内的元素个数</span>        left <span class="token operator">=</span> ans <span class="token operator">=</span> cnt <span class="token operator">=</span>  <span class="token number">0</span> <span class="token comment">#cnt统计相同元素</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            cnt <span class="token operator">+=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment">#与当前元素加入窗口之前的相同元素成对</span>            <span class="token keyword">while</span> cnt <span class="token operator">&gt;=</span> k<span class="token punctuation">:</span>                cnt <span class="token operator">-=</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>                c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            ans <span class="token operator">+=</span> left        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li>时间复杂度:O（n）</li><li>空间复杂度:O（n）</li></ul><p>Q&amp;A:</p><p>Q:为什么对于每一个加入进窗口的元素，假设窗口内有<em>k</em>个该元素，那么相同元素对数结果需要加<em>k</em>？</p><p>A：当一个新元素进入窗口，此时窗口内每一个和它相同的元素均能和它组成一对，而窗口中一个有<em>k</em>个这样的元素，故结果加<em>k</em>即可。</p><p>Q：为什么在每次统计时，答案加<em>left</em> 即为”<strong>以当前<em>right</em>指针指向元素</strong>“作为<strong>子数组右端点</strong>的满足题意的子数组个数。</p><p>A：经过分析可知，题目为越长越合法求子数组个数的类型。每一次遍历实际上是在找<strong>以当前的right指针作为窗口的右端点</strong>，会有多少个符合题意的子数组。接下来分两种情况：</p><ul><li><p>当<em>right</em>不断增加，但合法的窗口还没构成时:<br>此时<em>left</em>不会发生任何移动，依然是初始值<em>0</em>，也就是加上<em>left</em>也不会对结果有任何影响。</p></li><li><p>当合法的窗口已经构成时，需要移动<em>left</em>使其不合法:</p><p>对于<em>right</em>来说，由于经历了<em>while</em>循环使得这个窗口<strong>恰好</strong>重新不合法，也就是在此时<em>left</em>指针指向元素之前的<strong>所有元素</strong>，与当前的<em>right</em>指针指向的元素构成的子数组都是合法的，一共有<em>left</em>个元素(下标为<em>left</em>代表前面有<em>left</em>个元素)。</p></li></ul><blockquote><p>注：多理解：</p><ul><li>越长越合法</li><li><em>left</em>指针指向的元素是恰好让窗口不合法的端点元素</li></ul></blockquote><p><strong>6.K个不同整数的子数组</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/" title="K个不同整数的子数组">992.K 个不同整数的子数组</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。子数组 是数组的 连续 部分。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：nums = [1,2,1,2,3], k = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].示例 2：输入：nums = [1,2,1,3,4], k = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].- [4,3,2,2,4] 有 2 对。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= nums.length &lt;= 2 * 1041 &lt;= nums[i], k &lt;= nums.length</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">对于这种要找一个子数组，使其恰好满足某种条件的问题，可以将其转换为：1.两个越长越合法类型的差2.两个越短越合法的类型的差要找不同整数个数恰好为k个的子数组，可以先找”不同整数个数大于k”和“不同整数个数大于等于k”的子数组个数再用两者做差，即可得到不同整数个数等于k的子数组个数。要找到这样的子数组，自然是越长越合法，故这是转换为第一种情况。或者也可以找“不同整数个数小于等于k”和“不同整数个数小于k”的子数组个数。依然是两个答案做差得到答案。而要找到这样的子数组，则变成了越短越合法，故这是转换为第二种情况。而大于k等价于大于等于k+1，小于k等价于小于等于k-1.故只需要写一个方法，传递不同的参数即可得到需要的答案。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraysWithKDistinct_atleast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>         <span class="token triple-quoted-string string">"""        转换为越长越合法        """</span>        <span class="token keyword">def</span> <span class="token function">atleast</span><span class="token punctuation">(</span>j<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>            ans <span class="token operator">=</span> left <span class="token operator">=</span> <span class="token number">0</span>            c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">#记录当前窗口内的元素</span>            <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#当字典长度大于等于j，说明此时字典内不同元素个数足够，窗口合法</span>                <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> j<span class="token punctuation">:</span>                    c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">if</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">del</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span>                    left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#越长越合法每次直接加left</span>                ans <span class="token operator">+=</span> left            <span class="token keyword">return</span> ans        <span class="token keyword">return</span> atleast<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">-</span> atleast<span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">def</span> <span class="token function">subarraysWithKDistinct_atmost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>         <span class="token triple-quoted-string string">"""        转换为越短越合法        """</span>        <span class="token keyword">def</span> <span class="token function">atmost</span><span class="token punctuation">(</span>j<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>            ans <span class="token operator">=</span> left <span class="token operator">=</span> <span class="token number">0</span>            c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">#记录当前窗口内的元素</span>            <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#当字典长度大于j，说明此时字典内不同元素个数超过了k，窗口不合法</span>                <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;</span> j<span class="token punctuation">:</span>                    c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">if</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">del</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span>                    left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#越短越合法每次统计整个[left,right]区间内的所有子数组</span>                ans <span class="token operator">+=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">return</span> ans        <span class="token keyword">return</span> atmost<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">-</span> atmost<span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>复杂度分析:</p><ul><li>时间复杂度:O（n）两次<em>atleast</em>或<em>atmost</em>的时间复杂度均为O（n），故总体时间复杂度也为O（n）</li><li>空间复杂度:O（k）字典的长度不会超过题目所给出的长度，故空间复杂度为O（k），k为题目要求的数组中恰好有的值的个数。</li></ul><p>Q&amp;A:</p><p>Q:为什么这类题不能像之前的滑动窗口一样，先构建一个合法窗口，再通过移动左指针缩小窗口，每次找到合法的子数组就将答案加一呢?</p><p>A:<em><em>因为不能确保单调性！！！*<em>此类题目没有办法确保当子数组增大，它会越来越符合题意或是越来越不符合题意。以此题为例，假设有这样一个输入：<br>$$<br>nums = [1,1,1,2,3,1,1],k = 3<br>$$<br>若按照前面题目的套路，当</em>left*＝0，<em>right</em>=4时符合条件，此时</em>ans*+1，再右移<em>left</em>，直到*left</em>=3指向2不符合条件时，继续移动<em>right</em>使其重新满足条件。此时<em>right</em>=5，指向列表中的第四个1，又重新符合题意。但是这个<em>right</em>和当前<em>left</em>左边所有元素构成的窗口也依然符合题意。故这种方法不成立。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>能否使用定长滑动窗口解题往往在题干中有比较明显的暗示。而在一道题目能否使用普通滑动窗口，最关键的部分就在于判断题目是否具有单调性。充分利用具有单调性的题目的两条性质（此处以越长越合法举例）:</p><ul><li>若left….right符合题意，那么left…..right + 1、right + 2…len(nums)依然符合题意</li><li>若left….right不符合题意，那么left、left + 1、left + 2…right…right也依然不符合题意</li></ul><p>明确滑动窗口每一次移动<em>right</em>指针实际上是寻找<strong>以当前<em>right</em>指针指向的元素作为子数组的右端点</strong>，<strong>所有符合条件的子数组</strong>的过程。</p><ul><li><p>对于越短越合法求最长的类型，当计算答案时，由于中间符合条件的子数组反而更短，故无需考虑</p></li><li><p>对于越长越合法求最短的类型，当计算答案时，由于中间符合条件的子数组反而更长，故无需考虑</p></li><li><p>对于求个数类型的滑动窗口，当计算答案时，分别用:<br>$$<br>ans += right - left + 1<br>$$<br>和:<br>$$<br>ans += left<br>$$<br>加上所有合法结果即可。</p></li></ul><p>以上为这篇博客的所有内容，欢迎各位友好交流，如有不对之处请批评指正，希望能对你有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 与 JavaScript：从浏览器走向全栈的关键一步</title>
      <link href="/2025/08/12/node.js-yu-javascript-cong-liu-lan-qi-zou-xiang-quan-zhan-de-guan-jian-yi-bu/"/>
      <url>/2025/08/12/node.js-yu-javascript-cong-liu-lan-qi-zou-xiang-quan-zhan-de-guan-jian-yi-bu/</url>
      
        <content type="html"><![CDATA[<p>在最初的互联网时代，JavaScript 只是浏览器里的“小角色”，负责让网页动起来、能互动。然而，随着 Web 应用的复杂度不断提高，前后端分属两种语言的开发模式变得低效而割裂。Node.js 的诞生，让 JavaScript 从浏览器的前端脚本摇身一变，成为可以同时驾驭前端与后端的“全栈语言”。本篇博客将带梳理 JavaScript 与 Node.js 的关系，以及它们如何共同推动现代 Web 开发的演变。</p><h2 id="JavaScript的诞生"><a href="#JavaScript的诞生" class="headerlink" title="JavaScript的诞生"></a>JavaScript的诞生</h2><p>最早的浏览器页面由 HTML 和 CSS 两种文件构成。其中，HTML 负责描述页面的内容，如：“今天的天气”，“文章的标题”等。CSS 则负责规定这些页面内容该以什么样的形式展示，如：“标题的位置”，“标题的大小”。但是这样写出来的 HTML 页面是静态的、不可交互的，页面必须在每次对文件修改后刷新才能显示成最新的样子。为了使浏览器变得动态、可交互，1995 年，JavaScript 作为一种全新的语言诞生了。</p><h2 id="浏览器页面语言的“分工”"><a href="#浏览器页面语言的“分工”" class="headerlink" title="浏览器页面语言的“分工”"></a>浏览器页面语言的“分工”</h2><p>哪怕到 2025 年的今天，浏览器页面的构成也依然是“HTML + CSS + JavaScript”，这三种语言有着不同的分工，具体如下。</p><ul><li><strong>HTML</strong>: 定义页面内容的<strong>结构与语义</strong>（如标题、段落、图片等元素的层级关系）</li><li><strong>CSS</strong>: 控制页面内容的<strong>视觉呈现</strong>（布局、颜色、动画等样式）</li><li><strong>JavaScript</strong>: 实现页面的<strong>动态行为与交互逻辑</strong>（数据更新、事件响应等）</li></ul><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/Screenshot%202025-08-12%20104225.png" alt="Html + CSS说明图"></p><p>以上图为例，在 HTML 中定义了这个页面应该有“开源”、“企业版”、“高校版”等文字，在 CSS 中定义了这些文字应该以这个大小，这个颜色出现在页面中。<br><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/Screenshot%202025-08-12%20105621.png" alt="JavaScript说明图"></p><p>而在这张图中，当点击右上角的 English 按钮后，整个页面切换成英文显示，这便是通过 JavaScript 来监听点击事件，实现了与浏览器之间的交互。</p><h2 id="计算机是如何识别-JavaScript-等高级语言的"><a href="#计算机是如何识别-JavaScript-等高级语言的" class="headerlink" title="计算机是如何识别 JavaScript 等高级语言的"></a>计算机是如何识别 JavaScript 等高级语言的</h2><p>众所周知，计算机只能识别一系列机器码，对于开发者来说，要用计算机可识别的机器码进行开发是十分困难的。于是，在此基础上，有了汇编语言。汇编语言是一种低级语言（亦称符号语言），用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过<strong>汇编器</strong>转换成机器指令。</p><p>相对于机器语言，汇编语言的开发相对来说简单了一些，但依然复杂。于是，就有了一系列的高级语言，如 C++、Java、Python、JavaScript 等。每一种高级语言都有专门的<strong>工具</strong>将它们转换成机器可识别并执行的机器码，并按照开发者的意思给出结果。</p><ul><li><strong>Python</strong>：主要通过 <strong>解释器</strong>（如官方发行版自带的 <strong>CPython</strong>）将代码翻译并执行。</li><li><strong>Java</strong>：通过 <strong><code>javac</code> 编译器</strong>（JDK 提供）将源代码编译成字节码，再由 <strong>JVM（Java 虚拟机）</strong> 解释执行或即时编译为机器码。</li><li><strong>JavaScript</strong>：依赖<strong>引擎</strong>（如 Chrome 浏览器中的 <strong>V8 引擎</strong>）将代码转成机器码执行。</li></ul><p>需要注意的是，JavaScript 引擎只实现了 ECMAScript 语言规范，而像 DOM 操作、<code>window</code>、<code>document</code> 等是浏览器提供的 Web API，不属于 JavaScript 语言本身。JavaScript 诞生之初就是为了在浏览器中运行，因此这些 API 最初只存在于浏览器环境中。</p><h2 id="Node-js的诞生"><a href="#Node-js的诞生" class="headerlink" title="Node.js的诞生"></a>Node.js的诞生</h2><p>传统上，JavaScript 只能运行在浏览器环境中。当 Web 应用需要与后端服务器或数据库交互时，如果允许浏览器中的 JavaScript 直接访问系统资源，会带来严重的安全风险。因此，浏览器端与后端必须隔离，后端通常由其他语言编写。</p><p>Node.js 的出现改变了这一点——它基于 Chrome 的 V8 JavaScript 引擎构建，提供了一个独立于浏览器的 JavaScript 运行时环境。这样，开发者可以<strong>用 JavaScript 编写服务器端代码</strong>，运行在服务器上处理业务逻辑、访问数据库、操作文件等。前端（浏览器端）和后端（服务器端）都可以统一使用 JavaScript 进行开发，从而降低学习成本，并通过 API 接口实现安全的数据交互。</p><p>⚠️ 注意：Node.js 并不会让浏览器端的 JavaScript 获得访问本地文件系统的能力，它是一个单独运行的环境，通常在服务器或本地开发机上执行。</p><h2 id="Node-js的实际作用"><a href="#Node-js的实际作用" class="headerlink" title="Node.js的实际作用"></a>Node.js的实际作用</h2><p>JavaScript 代码一般有两种编写和运行方式：</p><ul><li><strong>在 HTML 文件中通过 <code>&lt;script&gt;</code> 标签</strong> 来定义交互行为：运行在浏览器中，能调用 Web API，但不能访问系统文件。</li><li><strong>通过 Node.js 在各种 IDE 或命令行中运行 <code>.js</code> 文件</strong>：Node.js 内置了 V8 引擎和自己的 API（如 <code>fs</code> 模块），可以访问文件系统和网络资源（权限范围内）。</li></ul><p>运行 JavaScript 文件的方式包括：</p><ul><li>在 IDE 中点击运行按钮</li><li>在命令行中执行：<br></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> 文件名.js</code></pre><p>可以把 JavaScript 和 Node.js 的关系类比为：JavaScript 是“接待员”，Node.js 是“管理员兼仓库钥匙”，而操作系统中的数据文件是“仓库里的货物”。Node.js 内置了 V8 引擎，因此既能理解接待员的语言，又能带着权限去仓库取货。</p><p>如今，Node.js 在前端开发中几乎是必不可少的。它不仅是运行 JavaScript 的环境，还集成了大量开源工具和库，比如构建工具 <strong>webpack</strong>、静态博客工具 <strong>hexo</strong> 等。这些工具本质上都是用 JavaScript 编写的程序，可以通过 <strong>npm（Node Package Manager）</strong> 安装：<br></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> 库名</code></pre><p>npm 是 Node.js 自带的包管理工具，用来安装、管理和发布 JavaScript 包（库）。</p><p>而安装一些命令行工具，如<strong>hexo,vue</strong>等，实际上就是在安装一系列JavaScript文件，并在安装的过程中注册这些命令。在执行某些命令，如hexo -g时,命令行工具会<strong>自动找到该命令对应的JavaScript</strong>文件并通过<strong>Node.js</strong>执行。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从最初只存在于浏览器中的前端脚本，到如今在服务器端同样大放异彩，JavaScript 的舞台早已不再局限于网页。Node.js 不仅让 JavaScript 跨越了前后端的鸿沟，还推动了全栈开发模式的普及。无论是构建高性能的 API 服务，还是搭建个人博客、命令行工具，Node.js 都提供了稳定而强大的运行环境。理解 JavaScript 与 Node.js 的关系，不仅是学习前端开发的基础，更是迈向全栈开发的重要一步。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Node.js </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法:定长滑动窗口类型题目总结</title>
      <link href="/2025/07/29/suan-fa-ding-chang-hua-dong-chuang-kou-lei-xing-ti-mu-zong-jie/"/>
      <url>/2025/07/29/suan-fa-ding-chang-hua-dong-chuang-kou-lei-xing-ti-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="定长滑动窗口介绍"><a href="#定长滑动窗口介绍" class="headerlink" title="定长滑动窗口介绍"></a>定长滑动窗口介绍</h1><p>定长滑动窗口指的是–在一定背景条件下，从列表当中找到连续k个元素，使得他们满足如：“这些元素的和最大”，“这些元素的和最小”等条件并将结果返回。将这些连续元素构成的子列表称作窗口。<br></p><p>一般来说，定长滑动窗口类型的题目在题干中会给出很明显的提示，比如：”一个大小为k的连续子串”，“可以保持连续minutes分钟不生气”。看到此类固定值出现在题目中，就应该考虑使用定长滑动窗口了。<br></p><h1 id="定长滑动窗口分类"><a href="#定长滑动窗口分类" class="headerlink" title="定长滑动窗口分类"></a>定长滑动窗口分类</h1><p>定长滑动窗口一般分为两类，第一类为统计类，第二类为计算类<br></p><ul><li>统计类:指的是需要统计子列表中某些类型元素的个数，找到拥有该类型元素个数最多或最少的子列表，记录值并返回。<br></li><li>计算类:指的是需要计算子列表当中的元素，找到当中元素和最大或者最小的子列表，记录值并返回。<br></li></ul><h1 id="定长滑动窗口的一般求解方法"><a href="#定长滑动窗口的一般求解方法" class="headerlink" title="定长滑动窗口的一般求解方法"></a>定长滑动窗口的一般求解方法</h1><p>这类题目的解法一般遵循三部曲</p><ul><li>创造窗口(入)</li><li>更新结果(算)</li><li>拆除窗口(出)</li></ul><p>正如前文所说，我们要找的是由一系列大小为k的连续元素构成的窗口，那么第二个窗口和第一个窗口实际上只有一个元素不同，即第一个窗口的最左边元素和第二个窗口的最右边元素。后面的窗口以此类推。<br></p><p>如果我们已知第一个窗口(由列表最开始的k个元素构成)的信息,比如:”第一个窗口内有多少个元音字母”,”第一个窗口的元素和是多少”。此时我们想要知道第二个窗口的信息，那么只需要判断第一个窗口最左边的元素是否也被纳入了计算或者统计当中，如果是，那么就用第一个窗口得到的值减去最左边元素对该值的贡献，再将第二个窗口最右边的值的贡献加入，即可得到第二个窗口的值。<br></p><p>这样的一个过程便是三部曲的体现。具体模板代码如下。<br></p><pre><code class="language-python">class Solution:    def funcname(self,nums:list[int],k:int) -&gt; int:        """        nums:为待处理的列表        k:为题目规定的窗口大小        """        ans = res = 0 #定义两个值，分别用来存放全局结果和局部结构        for i in range(len(nums)):            #1.构建窗口            ans += nums[i]            if i &lt; k - 1:                continue            #2.更新结果            res = max(res,ans)            #3.拆除窗口            ans -= nums[i - k + 1]        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
