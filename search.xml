<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hot100:三数之和</title>
      <link href="/2025/09/14/hot100-san-shu-zhi-he/"/>
      <url>/2025/09/14/hot100-san-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode.cn/problems/3sum/" title="三数之和">Hot100 - LeetCode15:三数之和</a></p><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><h2 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h2><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。</code></pre><h2 id="题目规模"><a href="#题目规模" class="headerlink" title="题目规模"></a>题目规模</h2><ul><li>3 &lt;= nums.length &lt;= 3000</li><li>-10^5 &lt;= nums[i] &lt;= 10^5</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要找的是满足条件的三元组，且三元组当中为具体的值，故数组的下标并不重要，排序不会影响最后的结果，可以先排序。</p><p>要找三个数组下标i,j,k，使得：<br>$$<br>nums[i] + nums[j] + nums[k] = 0<br>$$<br>可以依次固定数组中的每一个数，再从该数的右边找到两个数，使其相加满足条件，这样就将题目转换成了target为nums[i]的两数之和，如图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250914224213937.png" alt="演示图片"></p><p>具体的实现思路如下:</p><ul><li><p>从左往右遍历排序后的数组，将当前遍历到的值固定，记指针为<strong>i</strong></p></li><li><p>从子数组[i + 1,len(nums) - 1]中找到两个指针<strong>j</strong>、<strong>k</strong>,使得:<br>$$<br>nums[j] + nums[k]  = -nums[i]<br>$$</p></li><li></li></ul><p>排序后的数组具有单调性</p><ul><li>当<em>nums[i] + nums[j] + nums[k] &lt; 0</em>时，需要整体值增加，右移<strong>j指针</strong></li><li>当<em>nums[i] + nums[j] + nums[k] &gt; 0</em>时，需要整体值减小，左移<strong>k指针</strong></li><li>当<em>nums[i] + nums[j] + nums[k]  = 0</em>时，找到了一组可行的答案，进入下列步骤</li></ul><p>由于题目要求答案中不可以包含重复的三元组，故<strong>每一次遍历前</strong>和<strong>找到符合题意的解后</strong>还需要将指针移动到特定的位置，具体的步骤如下:</p><ul><li>在遍历前，若当前固定值和上一个固定值相同，可以直接跳过这次遍历</li><li>找到符合题意的答案后，将<strong>j</strong>和<strong>k</strong>分别移动到与当前指向元素不同的的第一个元素</li></ul><p>总结排序后的两步:</p><p>1.依次固定每个值，将题目转换为两数之和，从当前固定值之后找到两个元素，使其形成符合题意的三元组</p><p>2.通过移动指针进行去重操作</p><p>循环上述两步即可找到所有答案。</p><h2 id="思路补充"><a href="#思路补充" class="headerlink" title="思路补充"></a>思路补充</h2><p>Q：<strong>为什么只用从当前固定值的右边找两个元素，而不用再从左边找了?</strong></p><p>A：因为在之前的遍历中就已经把所有包含左边元素的解加入到了答案列表。</p><p>Q：<strong>为什么找到符合题意的答案后，要将<em>j</em>和<em>k</em>分别移动到与当前指向元素不同的的第一个元素？</strong></p><p>A：对于数组[a,b,b,c,e,d,d]，设有 <strong>a + b + d  = 0</strong>，若仅仅只是简单移动两个指针，将会重复加入答案[a,b,d]，故需要将两个指针分别移动到c和e，以确保不会重复。</p><p>Q：<strong>在遍历前，若当前固定值和上一个固定值相同，可以直接跳过这次遍历？</strong></p><p>A：由于数组已经排序完毕，故相同的元素将会挨在一起。假设存在重复元素<strong>a</strong>，当固定到第一个<strong>a</strong>时，由于是从其之后找剩下两个符合题意的元素，此时分为两种情况：</p><ul><li><p>三元组只包含一个a。</p></li><li><p>三元组包含多个a。若a不等于0，则三元组最多包含两个a</p></li></ul><p>对于第一种情况，将第一个a之后的其它a当作固定值，得到的答案和第一个a当作固定值的答案是完全相同的。</p><p>对于第二种情况，将第一个a之后的其它a当作固定值，得到的答案可能会因为在它之后a的数量不够，而少了一种或两种解。</p><p>换言之，无论是哪种情况，<strong>将之后的a当作固定值得到的答案的集合</strong>只不过是<strong>将第一个a当作固定值得到的答案的集合</strong>的子集罢了，故可以直接跳过重复值的遍历。</p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#如果最小的三个数的和都大于0，那么无解</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment">#如果最大的三个数的和都小于0，那么无解</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment">#固定到len(nums) - 2，因为最后两个元素凑不出三元组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#重复元素直接跳过判断</span>            <span class="token keyword">if</span> i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            k <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token comment">#转为两数之和</span>            <span class="token keyword">while</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>                <span class="token comment">#说明小了</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    j <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#说明大了</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    k <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token comment">#找到和左指针相同的最后一个元素</span>                    <span class="token keyword">while</span> j <span class="token operator">&lt;</span> k <span class="token keyword">and</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                        j <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token comment">#找到和右指针相同的最后一个元素</span>                    <span class="token keyword">while</span> j <span class="token operator">&lt;</span> k <span class="token keyword">and</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>                        k <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token comment">#移动到不同元素的位置</span>                    j <span class="token operator">+=</span> <span class="token number">1</span>                    k <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans    </code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O（n²）。每次循环遍历的长度和为<br>$$<br>（n - 1） +（ n - 2） +（ n - 3） +…. + 2，<br>$$</li></ul><p>故时间复杂度为O（n²）。</p><ul><li>空间复杂度：O（1）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hot100 </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法:滑动窗口类型题目总结</title>
      <link href="/2025/08/26/suan-fa-hua-dong-chuang-kou-lei-xing-ti-mu-zong-jie/"/>
      <url>/2025/08/26/suan-fa-hua-dong-chuang-kou-lei-xing-ti-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是滑动窗口"><a href="#什么是滑动窗口" class="headerlink" title="什么是滑动窗口"></a>什么是滑动窗口</h1><p>滑动窗口是算法题当中一种常见的解题方法，属于双指针的一种，常用于数据结构为数组（列表）、字符串类型的题目。其目的在于通过维护两个指针left、right，并将left和right当作题目给出数组（列表）、字符串中的一个子数组（列表）、字符串的左右端点，通过不断增大两指针的值，使得由两指针维护的窗口始终满足题目所给要求，最后计算答案。</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250826162157075.png" alt="一个符合题意的最大窗口"></p><p>如上图所示，在算法刚开始执行时窗口会先不断扩大，此时可以确保由left指向的a0作为左端点和right指向的a3作为右端点所构成的窗口是符合题意的。假设当窗口继续扩大，即right继续右移指向a4时，窗口不再满足题目要求，这个时候就需要通过右移left指向新的元素使得窗口缩小，以重新满足题目要求。假设当left指向a2时，由两指针构成的窗口可重新满足题意，如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250826163339407.png" alt="重新满足题意的窗口"></p><p>这样由a2到a4构成的新的窗口又重新满足了题意。最后只需根据题目要求，计算答案的个数即可。由于移动两个指针的过程就像是一个窗口在移动，故得名为滑动窗口。而定长滑动窗口则又是滑动窗口的一个特殊形式，它的窗口大小是固定的，也就是窗口的左右端点需要一起移动，在后文中会对定长滑动窗口进行举例介绍。双指针、滑动窗口、定长滑动窗口的关系如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250826164144380.png" alt="三者关系"></p><p>双指针是最基础的方法，滑动窗口是双指针的应用，定长滑动窗口是一种特殊的滑动窗口。</p><h1 id="滑动窗口的使用场景"><a href="#滑动窗口的使用场景" class="headerlink" title="滑动窗口的使用场景"></a>滑动窗口的使用场景</h1><p>当一道题目能用 <strong>滑动窗口解决</strong> 时，它一般符合以下三个特征：</p><ul><li>题目背景的数据结构为数组（列表）、字符串</li><li>题目需要求 “满足条件的子数组（列表）、子字符串个数”，或 “满足条件的子数组（列表）、子字符串的最大长度或个数”</li><li>滑动窗口适用的题目往往具有 <strong>单调性</strong></li></ul><p>对第三点做进一步说明：当窗口扩张时，窗口整体与题目条件的关系会呈现出一定的单调性：要么越容易满足条件（例如要求子数组和大于某个值 <em>k</em>，且数组元素为非负数时），要么越不容易满足条件。一旦窗口失去题意，就可以通过移动左指针缩小窗口来重新满足条件。这种单调性是滑动窗口能够高效发挥作用的关键。</p><p>当一道题目能使用更特别的 <strong>定长滑动窗口</strong> 时，除了符合上述的第一点，还应当满足以下特征：</p><ul><li>题目明确说明需要找一个大小为<em>k</em>的子数组（列表）、字符串，使其满足题目条件</li><li>题目要求在固定大小的窗口上进行统计或优化，例如 “统计该窗口内某类元素的个数”，或 “计算和、最大值、平均值等”</li></ul><p>相比一般滑动窗口，由于定长滑动窗口固定了窗口大小，寻找子数组的过程中无论结果如何左右指针都会一起移动，本身就不会回溯，故定长滑动窗口的使用对单调性并无要求，但其使用场景更为局限，判断条件更直观明确。</p><p><img src="http://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250827213223761.png" alt="有无单调性的数组对比"></p><p>普通滑动窗口能否使用的核心，仍然在于题目是否具有单调性。以找到元素和大于<em>k</em>的子数组为例：通过第一小节<strong>什么是滑动窗口</strong>我们知道，当窗口不满足条件时，右指针会右移使得窗口逐渐满足条件。对于上图中具有单调性的数组，随着指针不断右移，子数组将越来越符合条件，因为它每次都是增加一个正数，使得子数组和越来越接近<em>k</em>。而不含单调性的数组随着指针右移，它有时因为加了一个正数，使得子数组和离<em>k</em>越接近，但有时候又因为加了一个负数使得子数组和离<em>k</em>越遥远，这就是不含有单调性的具体体现。</p><p>关于单调性的必需的原因，将在下一节中介绍。</p><h1 id="一般滑动窗口的原理"><a href="#一般滑动窗口的原理" class="headerlink" title="一般滑动窗口的原理"></a>一般滑动窗口的原理</h1><blockquote><p><em>注:本小节若无特别说明，提到的滑动窗口指的均是一般滑动窗口，而非定长滑动窗口</em></p></blockquote><p>在介绍单调性对于使用一般滑动窗口的必要性之前，首先介绍滑动窗口的本质。</p><p>滑动窗口的本质实际上是对暴力解法的一种<strong>剪枝</strong>，也就是利用滑动窗口省去很大一部分不必要的判断。当我们需要找到一个数组的子数组，使其满足某种条件并统计个数或者返回需要满足的条件的值时，暴力解法是遍历这个数组当中的所有子数组，分别判断是否符合题意并记录结果，具体的解题伪代码如下:<br></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">Brute_Force</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        暴力法        nums为待遍历数组        """</span>        ans <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">#用来记录答案</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> meets the condition<span class="token punctuation">:</span>                    ans <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>不难判断暴力解法的时间复杂度为O（n²）。</p><p>当题目给出的数组<em>nums</em>具有单调性时，也就是要么子数组越长越容易满足条件要么子数组越短越容易满足条件，就可以省去很多不必要的判断，使得左右指针只用向一个方向移动，无需回溯。下文分别称这两种情况为越长越合法和越短越合法。当给出数组<em>nums</em>具有单调性时，一般会有以下<strong>两条性质</strong>:</p><ul><li>若由left 和 right构成的窗口不符合题意，那么由left 和 right + 1、right + 2、right + 3….len（<em>nums</em>） - 1 构成的窗口依然不符合题意</li><li>若由left 和 right构成的窗口符合题意,那么由left + 1、left + 2…..right 和 right 构成的窗口依然符合题意</li></ul><blockquote><p>注:上述两条性质适用于单调性为越短越合法的题目，对于单调性为越长越合法的题目，需将第一条性质中的两个不符合改为符合，将第二条性质中的符合改为不符合。*</p></blockquote><p>对于单调性为越短越合法的题目而言，子数组越大，该子数组就越不满足题目要求，如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250828102434545.png" alt="对性质一进行解释"></p><p>假设由left,right两指针构成的窗口<strong>恰好</strong>此时不满足条件了，由于单调性为越短越合法，也就是当窗口越大时，反而越不满足条件，那么由left和right之后的元素构成的窗口自然也是不满足条件的，之后就不用再进行判断了，这即为上述性质一。</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250828103312415.png" alt="对性质二进行解释"></p><p>如上图，假设由left和right构成的窗口此时是满足条件的，由于数组越短越合法，则从left到right之间的所有元素和right构成的窗口都是满足条件的，在后续又可以省去这一部分的判断，这即为上述性质二。</p><p>正如前文所说，滑动窗口类型的题目，left和right两个指针只会向同一个地方移动，绝不回溯，这正是因为题目具有单调性，两个指针的作用分别如下:</p><ul><li>右指针:负责扩大窗口使窗口不断满足题意，但在扩大窗口的过程中可能会由于新加入窗口的元素过大等原因，使得窗口不再满足题意</li><li>左指针:负责缩小窗口使窗口重新满足题意</li></ul><p>过程中左指针无需回溯可以理解成: 随着右指针的移动，窗口越来越大，直至不满足条件，左指针<strong>通过右移</strong>使其<strong>重新满足条件</strong>。如果左指针回溯到开始的位置重新遍历形成了一个大窗口，那么那段不符合题意的小窗口也依然包含在了这个大窗口中，由于越短越合法，故此时这个大窗口<strong>一定是不合法</strong>的，无需再进行判断。也就是说，<strong>性质一</strong>确保了左指针无需再回溯，只用从当前位置开始继续遍历。</p><p>过程中右指针无需回溯可以理解成: 当左指针发生了移动，说明此时右指针<strong>恰好停留在使得窗口不满足条件的位置</strong>，也就是当前右指针所指向位置的前一个元素，和先前的左指针以及两指针中间的元素所构成的窗口<strong>均合法</strong>，故右指针无需再回溯来判断它与当前左指针构成的新窗口是否依然合法，这是由上述<strong>性质二</strong>确保的。</p><p>越长越合法类型的滑动窗口同理。</p><p>滑动窗口的解题模板大致如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">sliding_windows</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        滑动窗口        """</span>        left <span class="token operator">=</span> ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#根据题目条件</span>            <span class="token comment">#计算需要的值</span>            <span class="token keyword">while</span> ans <span class="token keyword">not</span> meets the condition<span class="token punctuation">:</span>                <span class="token comment">#用计算出来的值</span>                <span class="token comment">#减去左指针指向的值</span>                left <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment">#左指针右移</span>            ans <span class="token operator">+=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">#越短越合法类型</span>            ans <span class="token operator">+=</span> left <span class="token comment">#越长越合法类型</span>        <span class="token keyword">return</span> ans</code></pre><p>由于外层循环是right不断右移直至数组的末尾，内层循环是left不断右移（不回溯）直至数组的末尾，每个数组元素<strong>最多被操作两次</strong>（一次进窗口、一次出窗口）。故时间复杂度为O（2n），省略常数项，滑动窗口的时间复杂度可以达到<strong>O（n）</strong>。</p><p>最后介绍单调性的必要性。倘若此时题目给出的数组不具有单调性，即有正有负。以找和小于<em>k</em>的子数组为例，假设在一个负数元素之前的所有元素均为正数，那么当该元素进入窗口时，它缩小了子数组的和，这就使得和小于<em>k</em>的子数组可能会<strong>出现在以当前left左边的元素为左端点的窗口中</strong>，如下图所示：</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250828111059431.png" alt="找到和<=4的子数组个数"></p><p>当*-5<em>进入窗口并作为窗口的右端点时，通过上文的分析我们知道，若具有单调性，由于*<em>性质一</em></em>，left不必回溯。但对于这种不具有单调性的情况，当*-5*进入窗口时，left指向下标为0的元素1，此时新窗口依然符合题意，也就是左指针此时需要回溯，并未达到节省时间复杂度的目的，不符合滑动窗口的逻辑，故不能使用滑动窗口，这也解释了为什么单调性是使用滑动窗口的必要条件。</p><h1 id="定长滑动窗口"><a href="#定长滑动窗口" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h1><p>定长滑动窗口是一种特殊的滑动窗口，常用在给定一个数组（列表）、字符串，寻找一个大小为<em>k</em>的子数组(列表)、字符串，使其满足“窗口和最大”、”窗口平均值最大”、”窗口内某元素数量最多”等条件。</p><p>以数组<em>nums</em>为例，由于<em>nums</em>中长度为<em>k</em>的子数组个数固定为<em>len（nums） - k + 1</em>，定长滑动窗口<strong>无论当前窗口结果</strong>如何，左右指针都要进行一次的移动来找到下一个窗口，也就是说，对于一个新的窗口而言，它与前一个窗口的区别在于首尾两个元素，如下图所示:</p><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/image-20250829094935530.png" alt="定长滑动窗口示例"></p><p>从窗口1变换为窗口2，left指针指向的元素出窗口，right’指针指向的元素进入窗口，也就是只要将统计值减去left指针指向元素带来的影响，再加上right’指针指向元素带来的影响，得到的就是新的窗口的统计值，再利用新窗口的统计值和当前最优统计值进行对比，找到最满足题意的统计值，记录并返回即可。</p><p>定长滑动窗口的三步曲如下:</p><ul><li>构建一个大小为<em>k</em>的窗口</li><li>记录当前窗口的统计值（如:窗口元素和、窗口元素平均值、窗口内某元素的个数）</li><li>统计值减去左指针指向值带来的影响，左指针右移、统计值加上右指针指向值带来的影响，右指针右移</li></ul><p>又由于窗口大小固定为<em>k</em>，故<em>left</em>指针指向的元素和<em>right</em>指针指向的元素有如下关系:<br>$$<br>left = right - k + 1<br>$$<br>因为<em>right</em>为大小为<em>k</em>的窗口的右端点，除去<em>right</em>指向元素以外，还需往前数<em>k-1</em> 个元素才到<em>left</em>指向元素，故实际上:<br>$$<br>left = right - (k - 1) = right - k + 1<br>$$<br>所以在实际的解题过程中，无需再定义一个左指针<em>left</em>，可直接用上述公式得到<em>left</em>所指向元素。</p><p>重复以上第二和第三步，直到统计完所有结果为止。</p><p>定长滑动窗口解题的伪代码如下:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fixed_size_sliding_windows</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">,</span>k<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        定长滑动窗口        k为窗口大小        nums为待进行寻找答案的列表        """</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> alllist        ans <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#1.构建窗口</span>            res <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>             <span class="token keyword">if</span> right <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                 <span class="token keyword">continue</span>            <span class="token comment">#2.记录窗口统计值，并与当前最优解比较</span>            ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>res<span class="token punctuation">)</span>            <span class="token comment">#3.统计值减去最左边元素带来的影响</span>            res <span class="token operator">-=</span> nums<span class="token punctuation">[</span>right <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>          <span class="token keyword">return</span> ans</code></pre><h1 id="滑动窗口例题"><a href="#滑动窗口例题" class="headerlink" title="滑动窗口例题"></a>滑动窗口例题</h1><h2 id="定长滑动窗口-1"><a href="#定长滑动窗口-1" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h2><p>定长滑动窗口的题目类型一般分为以下两种:</p><ul><li>找到大小为<em>k</em>的子数组，使其具有最大、最小的元素和等</li><li>找到大小为<em>k</em>的子数组，使子数组内某元素的个数最小或最大</li></ul><p>不管题目描述如何改变，最后都可以转化为上述两种类型。</p><blockquote><p><em>下文举例介绍定长滑动窗口</em></p></blockquote><p><strong>1.定长子串中元音的最大数</strong></p><p>题目链接：<a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/" title="定长子串中元音的最大数">1456.定长子串中元音的最大数</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给你字符串 s 和整数 k 。请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。英文中的 元音字母 为（a, e, i, o, u）。</code></pre><p>输入输出示例</p><pre class="language-none"><code class="language-none">示例 1：输入：s = "abciiidef", k = 3输出：3解释：子字符串 "iii" 包含 3 个元音字母。示例 2：输入：s = "aeiou", k = 2输出：2解释：任意长度为 2 的子字符串都包含 2 个元音字母。示例 3：输入：s = "leetcode", k = 3输出：2解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。示例 4：输入：s = "rhythms", k = 4输出：0解释：字符串 s 中不含任何元音字母。示例 5：输入：s = "tryhard", k = 4输出：1</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= s.length &lt;= 10^5s 由小写英文字母组成1 &lt;= k &lt;= s.length</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">这道题属于典型的定长滑动窗口类型二，给定一个大小为k的窗口，找到包含元音数量最多的那个窗口并返回结果。只需按照三部曲：1.构建第一个窗口并在该过程中统计元音个数2.将当前窗口的元音个数和当前最优解比较3.判断left指向的元素和right + 1指向的元素是否为元音字母，并作出相应操作具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxVowels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        定长滑动窗口        """</span>        vowels <span class="token operator">=</span> <span class="token string">'aeiou'</span> <span class="token comment">#记录元音字母</span>        ans <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment">#ans是返回值，res是临时变量</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#1.统计第一个窗口元音个数</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> right <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token comment">#2.和当前最优解比较</span>            ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>ans<span class="token punctuation">)</span>            <span class="token comment">#3.判断左指针指向元素的性质，并移动左指针</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>right <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                res <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li>时间复杂度:O（n）</li><li>空间复杂度:O（1）</li></ul><p><strong>2.可获得的最大点数</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/" title="可获得的最大点数">1423. 可获得的最大点数 </a></p><p>题目描述：</p><pre class="language-none"><code class="language-none">几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。你的点数就是你拿到手中的所有卡牌的点数之和。给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</code></pre><p>输入输出示例；</p><pre class="language-none"><code class="language-none">示例 1：输入：cardPoints = [1,2,3,4,5,6,1], k = 3输出：12解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。示例 2：输入：cardPoints = [2,2,2], k = 2输出：4解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。示例 3：输入：cardPoints = [9,7,7,9,7,7,9], k = 7输出：55解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。示例 4：输入：cardPoints = [1,1000,1], k = 1输出：1解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5：输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3输出：202</code></pre><p>题目规模：</p><pre class="language-none"><code class="language-none">1 &lt;= cardPoints.length &lt;= 10^51 &lt;= cardPoints[i] &lt;= 10^41 &lt;= k &lt;= cardPoints.length</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">这道题则对应定长滑动窗口题目的类型一，只不过需要用到逆向思维。由于抽牌只能从cardPoints的左右两边抽，并且只能抽k张，也就是最后牌组里会剩下len(cardPoints) - k张牌，且这k张牌是连续的。那么题目就变成了：从cardPoints中找到一个大小为len(cardPoints) - k的子数组，使得这个子数组的元素和最小。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxScore</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cardPoints<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        定长滑动窗口        窗口为0的话需要特判        """</span>        l <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span> <span class="token operator">-</span> k <span class="token comment">#逆向思维的窗口大小</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span>        ans<span class="token punctuation">,</span>res <span class="token operator">=</span><span class="token builtin">sum</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token comment">#ans记录答案，res记录中间值</span>        <span class="token keyword">for</span> right <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#1.构建窗口并记录值</span>            res <span class="token operator">+=</span> cardPoints<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            <span class="token keyword">if</span> right <span class="token operator">&lt;</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token comment">#2.与当前最优解比较</span>            ans <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>res<span class="token punctuation">)</span>            <span class="token comment">#3.移除左指针指向元素</span>            res <span class="token operator">-=</span> cardPoints<span class="token punctuation">[</span>right <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>cardPoints<span class="token punctuation">)</span> <span class="token operator">-</span> ans</code></pre><p>当窗口大小为0时需要特判。因为<em>res</em>减去的是窗口最左边的元素，如果一个窗口大小为0的话，那它将不存在所谓最左边的元素，代入进倒数第二行，当<em>right = len(cardPoints) - 1</em>时将会越界。</p><p>复杂度分析:</p><ul><li><p>时间复杂度:O（n）</p></li><li><p>空间复杂度:O（1）</p></li></ul><h2 id="不定长滑动窗口"><a href="#不定长滑动窗口" class="headerlink" title="不定长滑动窗口"></a>不定长滑动窗口</h2><p>不定长滑动窗口对题目有着严格的单调性要求，一般分为以下几种类型：</p><ul><li>越短越合法求最长的子数组</li><li>越长越合法求最短的子数组</li><li>求子数组的个数</li></ul><p>其中求子数组的个数又可以分为：</p><ul><li>求某值大于<em>k</em>的子数组个数</li><li>求某值小于<em>k</em>的子数组个数</li><li>求某值恰好等于<em>k</em>的子数组个数</li></ul><p>对于不定长滑动窗口，不管题目描述如何改变，大部分都能够转换为以上几种类型</p><blockquote><p><em>下文举例介绍不定长滑动窗口</em></p></blockquote><p><strong>1.无重复字符的最长子串</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/" title="无重复字符的最长子串">3. 无重复字符的最长子串</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1:输入: s = "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。示例 2:输入: s = "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。示例 3:输入: s = "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">0 &lt;= s.length &lt;= 5 * 104s 由英文字母、数字、符号和空格组成</code></pre><p>解题思路：</p><pre class="language-none"><code class="language-none">这是一道很经典的具有单调性的题目。子字符串越长，子字符串含有的字符就越多，含有重复字符的概率就越大，越不符合题意。可以判断这是一道越短越合法类型的题目，故可以采用滑动窗口。利用"滑动窗口的原理"小节中介绍的滑动窗口的两条性质，可以有效剪枝。具体代码如下。left不用回溯:越短越合法，回溯的话相当于依然包含了不合法子字符串right不用回溯:由于当right移动到不符合题意的位置时，left会移动使其重新符合题意。也就是在统计时，当前的窗口正是以当前right为右指针所构成的最大的能满足题意的窗口</code></pre><p>解题代码</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        不定长滑动窗口        越短越合法，求个数        """</span>        left <span class="token operator">=</span> ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment">#定义一个字典c来记录每个答案的个数</span>        c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#如果不符合题意了，就移动左指针让其重新符合题意</span>            <span class="token keyword">while</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>                c<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#每一次符合题意的子字符串长度都是right - left + 1</span>            ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li><p>时间复杂度:O（n）</p></li><li><p>空间复杂度:O（1）字符集大小为128，c的最大长度即为128，省略常数项，即为O（1）</p></li></ul><p><strong>2.将x减到0的最小操作数</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/" title="将x减到0的最小操作数">1658.将x减到0的最小操作数</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：nums = [1,1,4,2,3], x = 5输出：2解释：最佳解决方案是移除后两个元素，将 x 减到 0 。示例 2：输入：nums = [5,6,7,8,9], x = 4输出：-1示例 3：输入：nums = [3,2,20,1,1,3], x = 10输出：5解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= nums.length &lt;= 1051 &lt;= nums[i] &lt;= 1041 &lt;= x &lt;= 109</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">同定长滑动窗口例题2一样，这道题目依然可以利用逆向思维，将题目改写成:找到最大连续的子数组k，使其和为sum(nums) - x，如果存在,返回len(sums) - len(k)，否则返回-1判断题目的单调性。由于数组元素均为正数，当子数组越长，子数组和就越大，越不符合题意，故可以使用滑动窗口解决。但此时还应注意一种情况，由于此题采用的是逆向思维，按照前文，若当前窗口不符合题意，则需要移动左指针使其重新符合题意记要求的和为 i = sum(nums) - x，当前子数组和为j，则当j &gt; i时需要重新移动left但如果i＜0，即数组所有元素加起来的和也小于x，由于数组元素均为正数，无论怎么移动left指针，j &gt; i一定成立，此时会进入死循环。故需要特判这种情况，直接返回-1.具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minOperations</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        逆向思维        不定长滑动窗口        子数组越短越合法        """</span>        <span class="token comment">#特判所有元素不够加的情况</span>        <span class="token keyword">if</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&lt;</span> x<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span> <span class="token number">1</span>        ans <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token comment">#i为窗口要找的值</span>        i <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> x        left <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>j <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> j            <span class="token keyword">while</span> res <span class="token operator">&gt;</span> i<span class="token punctuation">:</span>                res <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#符合条件才记录答案</span>            <span class="token keyword">if</span> res <span class="token operator">==</span> i<span class="token punctuation">:</span>                ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>right <span class="token operator">-</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">#如果题目当中没有符合题意的子数组，ans = -1，直接返回-1，否则返回除去ans外剩下的元素长度</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> ans <span class="token keyword">if</span> ans <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token operator">-</span> <span class="token number">1</span></code></pre><p>复杂度分析:</p><ul><li><p>时间复杂度：O（n)</p></li><li><p>空间复杂度：O（1）</p></li></ul><p><strong>3.最小覆盖字串</strong></p><p>题目链接：<a href="https://leetcode.cn/problems/minimum-window-substring/submissions/657830960/" title="最小覆盖子串">76. 最小覆盖子串</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：s = "ADOBECODEBANC", t = "ABC"输出："BANC"解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。示例 2：输入：s = "a", t = "a"输出："a"解释：整个字符串 s 是最小覆盖子串。示例 3:输入: s = "a", t = "aa"输出: ""解释: t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</code></pre><p>题目规模：</p><pre class="language-none"><code class="language-none">m == s.lengthn == t.length1 &lt;= m, n &lt;= 105s 和 t 由英文字母组成</code></pre><p>解题思路：</p><pre class="language-none"><code class="language-none">首先明白覆盖的含义。当S的子字符串中的对应字符个数大于等于t中对应的字符个数，此时就说子字符串覆盖了t。再来看单调性，当S的子字符串越长，里面的字符就越多，就越有可能包括所有t中出现的字符串，故这是一道越长越合法类型的题目。在此基础上求最短的符合条件的子字符串。同理，先让窗口逐渐扩大，直到其符合条件。当其符合条件时，当前right指针指向的元素之后的所有元素与当前left指针指向元素所构成的窗口均符合题意，但长度不是最小，故由性质一进行剪枝，无需再判断。而Counter()可以很方便的的判断字符串中的字符个数并进行比较。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        越长越合法求最短        """</span>        c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>        d <span class="token operator">=</span> Counter<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        left<span class="token punctuation">,</span>cnt<span class="token punctuation">,</span>ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token string">""</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#此时覆盖了t字符串</span>            <span class="token keyword">while</span> c <span class="token operator">&gt;=</span> d<span class="token punctuation">:</span>                <span class="token keyword">if</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> cnt<span class="token punctuation">:</span>                    ans <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">:</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>                    cnt <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span>                c<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li><p>时间复杂度:O（<em>|Σ|·|s| + |t|</em>） <code>while c &gt;= d</code> 的条件在每次 <code>right</code> 移动时会判断一次（≤|s| 次），并且每次 <code>left</code> 移动也会导致一次判断（<code>left</code> 全程最多移动 ≤|s| 次），所以条件判断总次数 ≤ 2|s|，每次判断代价为 <code>O(|Σ|)</code>，再加上构造 <code>Counter(t)</code> 的 <code>O(|t|)</code>。当 |Σ| 为常数（如本题 52 个字母）时，复杂度可简化为 <code>O(|s| + |t|)</code>。</p></li><li><p>空间复杂度:O（1） 由于s和t均由英文字母构成，c和d大小最多为52，和为104，故空间复杂度为常数。</p></li></ul><p><strong>4.不间断子数组</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/continuous-subarrays/" title="不间断子数组">2762. 不间断子数组 </a></p><p>题目描述：</p><pre class="language-none"><code class="language-none">给你一个下标从 0 开始的整数数组 nums 。nums 的一个子数组如果满足以下条件，那么它是 不间断 的：i，i + 1 ，...，j  表示子数组中的下标。对于所有满足 i &lt;= i1, i2 &lt;= j 的下标对，都有 0 &lt;= |nums[i1] - nums[i2]| &lt;= 2 。请你返回 不间断 子数组的总数目。子数组是一个数组中一段连续 非空 的元素序列。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：nums = [5,4,2,4]输出：8解释：大小为 1 的不间断子数组：[5], [4], [2], [4] 。大小为 2 的不间断子数组：[5,4], [4,2], [2,4] 。大小为 3 的不间断子数组：[4,2,4] 。没有大小为 4 的不间断子数组。不间断子数组的总数目为 4 + 3 + 1 = 8 。除了这些以外，没有别的不间断子数组。示例 2：输入：nums = [1,2,3]输出：6解释：大小为 1 的不间断子数组：[1], [2], [3] 。大小为 2 的不间断子数组：[1,2], [2,3] 。大小为 3 的不间断子数组：[1,2,3] 。不间断子数组的总数目为 3 + 2 + 1 = 6 。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= nums.length &lt;= 1051 &lt;= nums[i] &lt;= 109</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">首先判断题目意思，找到一个子数组，使其中任意两个元素的差的绝对值均小于等于2。这等价于，找到一个子数组，使得该子数组中最大的元素和最小的元素差值小于等于2。再来判断题目的单调性，当子数组内元素越多，子数组中最大和最小的元素差就可能越大，就越不合法。故这是一个越短越合法类型的题目。题目要求统计合法的子数组个数，只需要每次统计时加上right - left + 1即可。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">continuousSubarrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        越短越合法        求数组个数        """</span>        left <span class="token operator">=</span> ans <span class="token operator">=</span> <span class="token number">0</span>        c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">#记录当前窗口的元素</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#如果不符合题意，就让它变成符合题意为止</span>            <span class="token keyword">while</span> <span class="token builtin">max</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">min</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">:</span>                c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                  <span class="token keyword">del</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            ans <span class="token operator">+=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li><p>时间复杂度:O（n）</p><p>将题目要求的差值设为M，即：<br>$$<br>0 &lt;= nums[i] - nums[j] &lt;= M(0 &lt;= i &lt;= j &lt;= len(nums) - 1)<br>$$<br>则时间复杂度为O（（M+1）n），其中n为数组的长度，原因如下：</p><p>每一次left指针的移动都伴随着<br>$$<br>max(c) - min(c)<br>$$<br>而字典调用这两个方法的逻辑是遍历整个字典，寻找最大的键。<strong>由于题目要求子数组内差值两两之间不能超过M，故最多有M + 1个元素会被存入字典中</strong>，max和min两个方法遍历的最坏情况也就是遍历M + 1个元素。而left最多移动n次，故时间复杂度是O（（M+1）n）。</p><p>而对于本题，M＝2，代入并省略常数项可得时间复杂度为O（n）。</p></li><li><p>空间复杂度:O（1）</p><p>空间复杂度即为定义的c的最大长度，理由同上。</p></li></ul><p>​故空间复杂度最大为O（M + 1）。对于本题，M＝2，代入并省略常数项可得空间复杂度为O（1）。</p><p>Q&amp;A：</p><p>Q:为什么子数组中最大的元素和最小的元素差值小于等于2即可满足条件?</p><p>A:可以看成一根数轴，子数组的最大和最小元素分别对应数轴两端，其余元素全在该数轴内，差的绝对值自然小于等于2.</p><p>Q:为什么统计时加上right - left + 1即可？</p><p>A:经过分析可知，该题目为越短越合法类型。由性质二可得，对于一个由left,right构成的窗口，如果它满足题意，那么从left到right之间（包含left和right）的所有元素和right构成的窗口均符合题意，这里一共有right - left + 1个元素，即有right - left + 1个合法子数组。而在统计时，对于每一个right，均能确保left在恰好使得窗口满足题意的位置，故直接加上right - left + 1即可。</p><p><strong>5.统计好子数组的数目</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/count-the-number-of-good-subarrays/description/" title="统计好子数组的数目">2537. 统计好子数组的数目 </a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i &lt; j 且 arr[i] == arr[j] ，那么称它是一个 好 子数组。子数组 是原数组中一段连续 非空 的元素序列。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：nums = [1,1,1,1,1], k = 10输出：1解释：唯一的好子数组是这个数组本身。示例 2：输入：nums = [3,1,4,3,2,2,4], k = 2输出：4解释：总共有 4 个不同的好子数组：- [3,1,4,3,2,2] 有 2 对。- [3,1,4,3,2,2,4] 有 3 对。- [1,4,3,2,2,4] 有 2 对。- [4,3,2,2,4] 有 2 对。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= nums.length &lt;= 1051 &lt;= nums[i], k &lt;= 109</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">首先分析题目意思，有k对元素相同，那就为一个好子数组，求子数组个数。即，找到子数组使其相同元素下标对数大于等于k，这是一个越长越合法求个数的问题。当子数组越大，子数组内元素就越多，相同元素出现的概率就越大，越可能满足题意。符合单调性，可以使用滑动窗口。对于每一个加入进窗口的元素，假设窗口内有k个该元素，那么相同元素对数结果需要加k。而在每次统计时，答案加left 即为”以当前right指针指向元素“作为数组右端点的满足题意的子数组个数。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countGood</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        越长越合法        求合法子数组个数        """</span>        c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">#记录窗口内的元素个数</span>        left <span class="token operator">=</span> ans <span class="token operator">=</span> cnt <span class="token operator">=</span>  <span class="token number">0</span> <span class="token comment">#cnt统计相同元素</span>        <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            cnt <span class="token operator">+=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment">#与当前元素加入窗口之前的相同元素成对</span>            <span class="token keyword">while</span> cnt <span class="token operator">&gt;=</span> k<span class="token punctuation">:</span>                cnt <span class="token operator">-=</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>                c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            ans <span class="token operator">+=</span> left        <span class="token keyword">return</span> ans</code></pre><p>复杂度分析:</p><ul><li>时间复杂度:O（n）</li><li>空间复杂度:O（n）</li></ul><p>Q&amp;A:</p><p>Q:为什么对于每一个加入进窗口的元素，假设窗口内有<em>k</em>个该元素，那么相同元素对数结果需要加<em>k</em>？</p><p>A：当一个新元素进入窗口，此时窗口内每一个和它相同的元素均能和它组成一对，而窗口中一个有<em>k</em>个这样的元素，故结果加<em>k</em>即可。</p><p>Q：为什么在每次统计时，答案加<em>left</em> 即为”<strong>以当前<em>right</em>指针指向元素</strong>“作为<strong>子数组右端点</strong>的满足题意的子数组个数。</p><p>A：经过分析可知，题目为越长越合法求子数组个数的类型。每一次遍历实际上是在找<strong>以当前的right指针作为窗口的右端点</strong>，会有多少个符合题意的子数组。接下来分两种情况：</p><ul><li><p>当<em>right</em>不断增加，但合法的窗口还没构成时:<br>此时<em>left</em>不会发生任何移动，依然是初始值<em>0</em>，也就是加上<em>left</em>也不会对结果有任何影响。</p></li><li><p>当合法的窗口已经构成时，需要移动<em>left</em>使其不合法:</p><p>对于<em>right</em>来说，由于经历了<em>while</em>循环使得这个窗口<strong>恰好</strong>重新不合法，也就是在此时<em>left</em>指针指向元素之前的<strong>所有元素</strong>，与当前的<em>right</em>指针指向的元素构成的子数组都是合法的，一共有<em>left</em>个元素(下标为<em>left</em>代表前面有<em>left</em>个元素)。</p></li></ul><blockquote><p>注：多理解：</p><ul><li>越长越合法</li><li><em>left</em>指针指向的元素是恰好让窗口不合法的端点元素</li></ul></blockquote><p><strong>6.K个不同整数的子数组</strong></p><p>题目链接:<a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/" title="K个不同整数的子数组">992.K 个不同整数的子数组</a></p><p>题目描述:</p><pre class="language-none"><code class="language-none">给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。子数组 是数组的 连续 部分。</code></pre><p>输入输出示例:</p><pre class="language-none"><code class="language-none">示例 1：输入：nums = [1,2,1,2,3], k = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].示例 2：输入：nums = [1,2,1,3,4], k = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].- [4,3,2,2,4] 有 2 对。</code></pre><p>题目规模:</p><pre class="language-none"><code class="language-none">1 &lt;= nums.length &lt;= 2 * 1041 &lt;= nums[i], k &lt;= nums.length</code></pre><p>解题思路:</p><pre class="language-none"><code class="language-none">对于这种要找一个子数组，使其恰好满足某种条件的问题，可以将其转换为：1.两个越长越合法类型的差2.两个越短越合法的类型的差要找不同整数个数恰好为k个的子数组，可以先找”不同整数个数大于k”和“不同整数个数大于等于k”的子数组个数再用两者做差，即可得到不同整数个数等于k的子数组个数。要找到这样的子数组，自然是越长越合法，故这是转换为第一种情况。或者也可以找“不同整数个数小于等于k”和“不同整数个数小于k”的子数组个数。依然是两个答案做差得到答案。而要找到这样的子数组，则变成了越短越合法，故这是转换为第二种情况。而大于k等价于大于等于k+1，小于k等价于小于等于k-1.故只需要写一个方法，传递不同的参数即可得到需要的答案。具体代码如下。</code></pre><p>解题代码:</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraysWithKDistinct_atleast</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>         <span class="token triple-quoted-string string">"""        转换为越长越合法        """</span>        <span class="token keyword">def</span> <span class="token function">atleast</span><span class="token punctuation">(</span>j<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>            ans <span class="token operator">=</span> left <span class="token operator">=</span> <span class="token number">0</span>            c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">#记录当前窗口内的元素</span>            <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#当字典长度大于等于j，说明此时字典内不同元素个数足够，窗口合法</span>                <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> j<span class="token punctuation">:</span>                    c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">if</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">del</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span>                    left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#越长越合法每次直接加left</span>                ans <span class="token operator">+=</span> left            <span class="token keyword">return</span> ans        <span class="token keyword">return</span> atleast<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">-</span> atleast<span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">def</span> <span class="token function">subarraysWithKDistinct_atmost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>         <span class="token triple-quoted-string string">"""        转换为越短越合法        """</span>        <span class="token keyword">def</span> <span class="token function">atmost</span><span class="token punctuation">(</span>j<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>            ans <span class="token operator">=</span> left <span class="token operator">=</span> <span class="token number">0</span>            c <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">#记录当前窗口内的元素</span>            <span class="token keyword">for</span> right<span class="token punctuation">,</span>i <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#当字典长度大于j，说明此时字典内不同元素个数超过了k，窗口不合法</span>                <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;</span> j<span class="token punctuation">:</span>                    c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">if</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">del</span> c<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span>                    left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment">#越短越合法每次统计整个[left,right]区间内的所有子数组</span>                ans <span class="token operator">+=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">return</span> ans        <span class="token keyword">return</span> atmost<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">-</span> atmost<span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>复杂度分析:</p><ul><li>时间复杂度:O（n）两次<em>atleast</em>或<em>atmost</em>的时间复杂度均为O（n），故总体时间复杂度也为O（n）</li><li>空间复杂度:O（k）字典的长度不会超过题目所给出的长度，故空间复杂度为O（k），k为题目要求的数组中恰好有的值的个数。</li></ul><p>Q&amp;A:</p><p>Q:为什么这类题不能像之前的滑动窗口一样，先构建一个合法窗口，再通过移动左指针缩小窗口，每次找到合法的子数组就将答案加一呢?</p><p>A:<em><em>因为不能确保单调性！！！*<em>此类题目没有办法确保当子数组增大，它会越来越符合题意或是越来越不符合题意。以此题为例，假设有这样一个输入：<br>$$<br>nums = [1,1,1,2,3,1,1],k = 3<br>$$<br>若按照前面题目的套路，当</em>left*＝0，<em>right</em>=4时符合条件，此时</em>ans*+1，再右移<em>left</em>，直到*left</em>=3指向2不符合条件时，继续移动<em>right</em>使其重新满足条件。此时<em>right</em>=5，指向列表中的第四个1，又重新符合题意。但是这个<em>right</em>和当前<em>left</em>左边所有元素构成的窗口也依然符合题意。故这种方法不成立。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>能否使用定长滑动窗口解题往往在题干中有比较明显的暗示。而在一道题目能否使用普通滑动窗口，最关键的部分就在于判断题目是否具有单调性。充分利用具有单调性的题目的两条性质（此处以越长越合法举例）:</p><ul><li>若left….right符合题意，那么left…..right + 1、right + 2…len(nums)依然符合题意</li><li>若left….right不符合题意，那么left、left + 1、left + 2…right…right也依然不符合题意</li></ul><p>明确滑动窗口每一次移动<em>right</em>指针实际上是寻找<strong>以当前<em>right</em>指针指向的元素作为子数组的右端点</strong>，<strong>所有符合条件的子数组</strong>的过程。</p><ul><li><p>对于越短越合法求最长的类型，当计算答案时，由于中间符合条件的子数组反而更短，故无需考虑</p></li><li><p>对于越长越合法求最短的类型，当计算答案时，由于中间符合条件的子数组反而更长，故无需考虑</p></li><li><p>对于求个数类型的滑动窗口，当计算答案时，分别用:<br>$$<br>ans += right - left + 1<br>$$<br>和:<br>$$<br>ans += left<br>$$<br>加上所有合法结果即可。</p></li></ul><p>以上为这篇博客的所有内容，欢迎各位友好交流，如有不对之处请批评指正，希望能对你有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 与 JavaScript：从浏览器走向全栈的关键一步</title>
      <link href="/2025/08/12/node.js-yu-javascript-cong-liu-lan-qi-zou-xiang-quan-zhan-de-guan-jian-yi-bu/"/>
      <url>/2025/08/12/node.js-yu-javascript-cong-liu-lan-qi-zou-xiang-quan-zhan-de-guan-jian-yi-bu/</url>
      
        <content type="html"><![CDATA[<p>在最初的互联网时代，JavaScript 只是浏览器里的“小角色”，负责让网页动起来、能互动。然而，随着 Web 应用的复杂度不断提高，前后端分属两种语言的开发模式变得低效而割裂。Node.js 的诞生，让 JavaScript 从浏览器的前端脚本摇身一变，成为可以同时驾驭前端与后端的“全栈语言”。本篇博客将带梳理 JavaScript 与 Node.js 的关系，以及它们如何共同推动现代 Web 开发的演变。</p><h2 id="JavaScript的诞生"><a href="#JavaScript的诞生" class="headerlink" title="JavaScript的诞生"></a>JavaScript的诞生</h2><p>最早的浏览器页面由 HTML 和 CSS 两种文件构成。其中，HTML 负责描述页面的内容，如：“今天的天气”，“文章的标题”等。CSS 则负责规定这些页面内容该以什么样的形式展示，如：“标题的位置”，“标题的大小”。但是这样写出来的 HTML 页面是静态的、不可交互的，页面必须在每次对文件修改后刷新才能显示成最新的样子。为了使浏览器变得动态、可交互，1995 年，JavaScript 作为一种全新的语言诞生了。</p><h2 id="浏览器页面语言的“分工”"><a href="#浏览器页面语言的“分工”" class="headerlink" title="浏览器页面语言的“分工”"></a>浏览器页面语言的“分工”</h2><p>哪怕到 2025 年的今天，浏览器页面的构成也依然是“HTML + CSS + JavaScript”，这三种语言有着不同的分工，具体如下。</p><ul><li><strong>HTML</strong>: 定义页面内容的<strong>结构与语义</strong>（如标题、段落、图片等元素的层级关系）</li><li><strong>CSS</strong>: 控制页面内容的<strong>视觉呈现</strong>（布局、颜色、动画等样式）</li><li><strong>JavaScript</strong>: 实现页面的<strong>动态行为与交互逻辑</strong>（数据更新、事件响应等）</li></ul><p><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/Screenshot%202025-08-12%20104225.png" alt="Html + CSS说明图"></p><p>以上图为例，在 HTML 中定义了这个页面应该有“开源”、“企业版”、“高校版”等文字，在 CSS 中定义了这些文字应该以这个大小，这个颜色出现在页面中。<br><img src="https://030803-1373963860.cos.ap-chongqing.myqcloud.com/Screenshot%202025-08-12%20105621.png" alt="JavaScript说明图"></p><p>而在这张图中，当点击右上角的 English 按钮后，整个页面切换成英文显示，这便是通过 JavaScript 来监听点击事件，实现了与浏览器之间的交互。</p><h2 id="计算机是如何识别-JavaScript-等高级语言的"><a href="#计算机是如何识别-JavaScript-等高级语言的" class="headerlink" title="计算机是如何识别 JavaScript 等高级语言的"></a>计算机是如何识别 JavaScript 等高级语言的</h2><p>众所周知，计算机只能识别一系列机器码，对于开发者来说，要用计算机可识别的机器码进行开发是十分困难的。于是，在此基础上，有了汇编语言。汇编语言是一种低级语言（亦称符号语言），用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过<strong>汇编器</strong>转换成机器指令。</p><p>相对于机器语言，汇编语言的开发相对来说简单了一些，但依然复杂。于是，就有了一系列的高级语言，如 C++、Java、Python、JavaScript 等。每一种高级语言都有专门的<strong>工具</strong>将它们转换成机器可识别并执行的机器码，并按照开发者的意思给出结果。</p><ul><li><strong>Python</strong>：主要通过 <strong>解释器</strong>（如官方发行版自带的 <strong>CPython</strong>）将代码翻译并执行。</li><li><strong>Java</strong>：通过 <strong><code>javac</code> 编译器</strong>（JDK 提供）将源代码编译成字节码，再由 <strong>JVM（Java 虚拟机）</strong> 解释执行或即时编译为机器码。</li><li><strong>JavaScript</strong>：依赖<strong>引擎</strong>（如 Chrome 浏览器中的 <strong>V8 引擎</strong>）将代码转成机器码执行。</li></ul><p>需要注意的是，JavaScript 引擎只实现了 ECMAScript 语言规范，而像 DOM 操作、<code>window</code>、<code>document</code> 等是浏览器提供的 Web API，不属于 JavaScript 语言本身。JavaScript 诞生之初就是为了在浏览器中运行，因此这些 API 最初只存在于浏览器环境中。</p><h2 id="Node-js的诞生"><a href="#Node-js的诞生" class="headerlink" title="Node.js的诞生"></a>Node.js的诞生</h2><p>传统上，JavaScript 只能运行在浏览器环境中。当 Web 应用需要与后端服务器或数据库交互时，如果允许浏览器中的 JavaScript 直接访问系统资源，会带来严重的安全风险。因此，浏览器端与后端必须隔离，后端通常由其他语言编写。</p><p>Node.js 的出现改变了这一点——它基于 Chrome 的 V8 JavaScript 引擎构建，提供了一个独立于浏览器的 JavaScript 运行时环境。这样，开发者可以<strong>用 JavaScript 编写服务器端代码</strong>，运行在服务器上处理业务逻辑、访问数据库、操作文件等。前端（浏览器端）和后端（服务器端）都可以统一使用 JavaScript 进行开发，从而降低学习成本，并通过 API 接口实现安全的数据交互。</p><p>⚠️ 注意：Node.js 并不会让浏览器端的 JavaScript 获得访问本地文件系统的能力，它是一个单独运行的环境，通常在服务器或本地开发机上执行。</p><h2 id="Node-js的实际作用"><a href="#Node-js的实际作用" class="headerlink" title="Node.js的实际作用"></a>Node.js的实际作用</h2><p>JavaScript 代码一般有两种编写和运行方式：</p><ul><li><strong>在 HTML 文件中通过 <code>&lt;script&gt;</code> 标签</strong> 来定义交互行为：运行在浏览器中，能调用 Web API，但不能访问系统文件。</li><li><strong>通过 Node.js 在各种 IDE 或命令行中运行 <code>.js</code> 文件</strong>：Node.js 内置了 V8 引擎和自己的 API（如 <code>fs</code> 模块），可以访问文件系统和网络资源（权限范围内）。</li></ul><p>运行 JavaScript 文件的方式包括：</p><ul><li>在 IDE 中点击运行按钮</li><li>在命令行中执行：<br></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> 文件名.js</code></pre><p>可以把 JavaScript 和 Node.js 的关系类比为：JavaScript 是“接待员”，Node.js 是“管理员兼仓库钥匙”，而操作系统中的数据文件是“仓库里的货物”。Node.js 内置了 V8 引擎，因此既能理解接待员的语言，又能带着权限去仓库取货。</p><p>如今，Node.js 在前端开发中几乎是必不可少的。它不仅是运行 JavaScript 的环境，还集成了大量开源工具和库，比如构建工具 <strong>webpack</strong>、静态博客工具 <strong>hexo</strong> 等。这些工具本质上都是用 JavaScript 编写的程序，可以通过 <strong>npm（Node Package Manager）</strong> 安装：<br></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> 库名</code></pre><p>npm 是 Node.js 自带的包管理工具，用来安装、管理和发布 JavaScript 包（库）。</p><p>而安装一些命令行工具，如<strong>hexo,vue</strong>等，实际上就是在安装一系列JavaScript文件，并在安装的过程中注册这些命令。在执行某些命令，如hexo -g时,命令行工具会<strong>自动找到该命令对应的JavaScript</strong>文件并通过<strong>Node.js</strong>执行。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从最初只存在于浏览器中的前端脚本，到如今在服务器端同样大放异彩，JavaScript 的舞台早已不再局限于网页。Node.js 不仅让 JavaScript 跨越了前后端的鸿沟，还推动了全栈开发模式的普及。无论是构建高性能的 API 服务，还是搭建个人博客、命令行工具，Node.js 都提供了稳定而强大的运行环境。理解 JavaScript 与 Node.js 的关系，不仅是学习前端开发的基础，更是迈向全栈开发的重要一步。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Node.js </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法:定长滑动窗口类型题目总结</title>
      <link href="/2025/07/29/suan-fa-ding-chang-hua-dong-chuang-kou-lei-xing-ti-mu-zong-jie/"/>
      <url>/2025/07/29/suan-fa-ding-chang-hua-dong-chuang-kou-lei-xing-ti-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="定长滑动窗口介绍"><a href="#定长滑动窗口介绍" class="headerlink" title="定长滑动窗口介绍"></a>定长滑动窗口介绍</h1><p>定长滑动窗口指的是–在一定背景条件下，从列表当中找到连续k个元素，使得他们满足如：“这些元素的和最大”，“这些元素的和最小”等条件并将结果返回。将这些连续元素构成的子列表称作窗口。<br></p><p>一般来说，定长滑动窗口类型的题目在题干中会给出很明显的提示，比如：”一个大小为k的连续子串”，“可以保持连续minutes分钟不生气”。看到此类固定值出现在题目中，就应该考虑使用定长滑动窗口了。<br></p><h1 id="定长滑动窗口分类"><a href="#定长滑动窗口分类" class="headerlink" title="定长滑动窗口分类"></a>定长滑动窗口分类</h1><p>定长滑动窗口一般分为两类，第一类为统计类，第二类为计算类<br></p><ul><li>统计类:指的是需要统计子列表中某些类型元素的个数，找到拥有该类型元素个数最多或最少的子列表，记录值并返回。<br></li><li>计算类:指的是需要计算子列表当中的元素，找到当中元素和最大或者最小的子列表，记录值并返回。<br></li></ul><h1 id="定长滑动窗口的一般求解方法"><a href="#定长滑动窗口的一般求解方法" class="headerlink" title="定长滑动窗口的一般求解方法"></a>定长滑动窗口的一般求解方法</h1><p>这类题目的解法一般遵循三部曲</p><ul><li>创造窗口(入)</li><li>更新结果(算)</li><li>拆除窗口(出)</li></ul><p>正如前文所说，我们要找的是由一系列大小为k的连续元素构成的窗口，那么第二个窗口和第一个窗口实际上只有一个元素不同，即第一个窗口的最左边元素和第二个窗口的最右边元素。后面的窗口以此类推。<br></p><p>如果我们已知第一个窗口(由列表最开始的k个元素构成)的信息,比如:”第一个窗口内有多少个元音字母”,”第一个窗口的元素和是多少”。此时我们想要知道第二个窗口的信息，那么只需要判断第一个窗口最左边的元素是否也被纳入了计算或者统计当中，如果是，那么就用第一个窗口得到的值减去最左边元素对该值的贡献，再将第二个窗口最右边的值的贡献加入，即可得到第二个窗口的值。<br></p><p>这样的一个过程便是三部曲的体现。具体模板代码如下。<br></p><pre><code class="language-python">class Solution:    def funcname(self,nums:list[int],k:int) -&gt; int:        """        nums:为待处理的列表        k:为题目规定的窗口大小        """        ans = res = 0 #定义两个值，分别用来存放全局结果和局部结构        for i in range(len(nums)):            #1.构建窗口            ans += nums[i]            if i &lt; k - 1:                continue            #2.更新结果            res = max(res,ans)            #3.拆除窗口            ans -= nums[i - k + 1]        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
